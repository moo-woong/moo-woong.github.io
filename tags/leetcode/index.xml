<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>LeetCode on Moo-woong</title>
    <link>https://moo-woong.github.io/tags/leetcode/</link>
    <description>Recent content in LeetCode on Moo-woong</description>
    <image>
      <url>https://moo-woong.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://moo-woong.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 05 Feb 2023 15:52:48 +0900</lastBuildDate><atom:link href="https://moo-woong.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode - Jewels and Stones </title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_771/</link>
      <pubDate>Sun, 05 Feb 2023 15:52:48 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_771/</guid>
      <description>LeetCode(771) - Jewels and Stones 문제 문자열 jewels와 stones가 주어진다. stones는 내가 가지고 있는 동의 종류들이고, jewels는 보석의 종류들이다. 내가 가지고 있는 돌들 중 보석이 몇개인지 반환하라.
입력 Input: jewels = &amp;quot;aA&amp;quot;, stones = &amp;quot;aAAbbbb&amp;quot; 출력 Output: 3 설명 stones는 중복이 가능하다. stones와 jewels의 각 문자는 대소문자가 구분된다.  풀이 stones를 순회하며 각 문자들을 map의 key로, 등장 횟수를 value로 저장한다. jewels를 순회하며 각 문자들을 map에서 검색 후 등장횟수들을 모두 카운트 후 반환한다.</description>
    </item>
    
    <item>
      <title>LeetCode - Degree of an Array</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_697/</link>
      <pubDate>Sun, 05 Feb 2023 15:22:58 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_697/</guid>
      <description>LeetCode(697) - Degree of an Array 문제 정수 배열 nums가 주어진다. nums에서 가장 많이 등장하는 정수를 찾고, nums에서 가장 많이 등장하는 정수를 포함하는 sub array를 만들 때, 배열의 길이를 구하라.
입력 Input: nums = [1,2,2,3,1] 출력 Output: 2 설명 가장 많이 등장하는 정수는 1과 2다. 1 혹은 2가 모두 포함되는 배열의 sub array를 만들 면 다음과 같다.  [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] 이 sub array 중 가장 짧은 배열의 길이를 갖는 배열은 [2, 2] 이며, 길이는 2이므로 2를 반환한다.</description>
    </item>
    
    <item>
      <title>LeetCode - Two Sum IV - Input is a BST</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_653/</link>
      <pubDate>Sun, 05 Feb 2023 15:09:52 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_653/</guid>
      <description>LeetCode(653) - Two Sum IV - Input is a BST 문제 Binary Search Tree의 root node 와 정수 k가 주어진다. BST정수 중 두 정수를 조합하여 k를 만들 수 있다면 true를, 아니라면 false를 반환하라.
  입력 Input: root = [5,3,6,2,4,null,7], k = 9 출력 Output: true 풀이 set은 key의 유일성을 보장하며, 고유한 key 검색 시 O(1)의 시간복잡도를 가진다. k - 특정 노드 값이면, 나머지 값에 대해 검색연산을 수행하여 값을 찾을 수 있다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Distribute Candies</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_645/</link>
      <pubDate>Sun, 29 Jan 2023 16:05:59 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_645/</guid>
      <description>LeetCode(645) - Set Mismatch 문제 정수형 set이 배열형태로 주어진다. set은 1부터 set의 크기인 n까지 중복되지 않은 값으로 채워져 있어야 한다. nums에 하나의 정수가 다른 정수(1 &amp;lt;= 다른정수&amp;gt; &amp;lt;= n)로 바뀌었다. 이 중복된 수와 원래 있어야 할 수를 찾아 배열 형태로 반환하라.
입력 Input: nums = [1,2,2,4] 출력 Output: [2,3] 풀이 주어진 배열에 대해 중복을 찾아야 하고, 빠진 값 또한 찾아야 한다. 중복된 배열은 map으로 고유성을 찾고, 누락 된 값은 정렬 후 index와 값을 비교하여 다르다면 누락된 값으로 간주한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Distribute Candies</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_599/</link>
      <pubDate>Sun, 29 Jan 2023 15:28:59 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_599/</guid>
      <description>LeetCode(599) - Minimum Index Sum of Two Lists 문제 문자열 배열 list1과 list2가 주어진다. 다음과 같은 조건을 갖는 문자열들을 반환하라.
 list1, list2모두에 존재하는 문자열 문자열 중, 가장 낮은 인덱스를 갖는 문자열 가장 낮은 index가 양쪽 배열 모두 동일하다면 두 문자열을 배열 형태로 반환.  입력 list1 = [&amp;quot;Shogun&amp;quot;,&amp;quot;Tapioca Express&amp;quot;,&amp;quot;Burger King&amp;quot;,&amp;quot;KFC&amp;quot;], list2 = [&amp;quot;Piatti&amp;quot;,&amp;quot;The Grill at Torrey Pines&amp;quot;,&amp;quot;Hungry Hunter Steakhouse&amp;quot;,&amp;quot;Shogun&amp;quot; 출력 Output: [&amp;quot;Shogun&amp;quot;] 풀이 문자열을 key로, index를 value로 하는 map에 list1의 문자열들을 삽입한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Longest Harmonious Subsequence</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_594/</link>
      <pubDate>Fri, 27 Jan 2023 23:37:58 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_594/</guid>
      <description>LeetCode(594) - Longest Harmonious Subsequence 문제 임의의 harmonious array를 정의한다.  harmonious array는 배열의 양 끝단의 수가 그 사이의 수보다 1이 더 큰 배열을 말한다. 배열 nums가 주어질 때, 해당 배열을가지고 가장 긴 harmonious array를 만들었을 때 자리수를 반환하라.
입력 Input: nums = [1,3,2,2,5,2,3,7] 출력 Output: 5  배열 1,3,2,2,5,2,3,7를 이용하여 harmonious array 3,2,2,2,3을 만들 수 있으므로 5를 반환한다.  풀이 map을 이용하여 각 숫자의 출현 횟수를 카운트 한다. map의 첫 번째 pair를 가르키는 prev변수를 생성하고 map을 순회한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Distribute Candies</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_575_distribute_candy/</link>
      <pubDate>Wed, 25 Jan 2023 00:29:52 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_575_distribute_candy/</guid>
      <description>LeetCode(575) - Distribute Candy 문제 Alice는 n개의 캔디를 가지고 있다. i 캔디는 candyTpye[i]의 타입이다. Alice는 살이쪄서 캔디를 줄여야한다..! 주치의는 Alice가 가지고 있는 캔디의 n/2만큼만 먹으라고 한다.
Alice는 최선의 선택을 하고싶다. n/2만큼을 먹어야한다면, 가능한한 많은 종류의 캔디를 먹고싶다. 만약 6종류의 캔디가 있다면, 3종류의 캔디를 먹고, 3종류의 캔디 총 6개가 있다면 있다면 n/2를 한 만큼인 3개만을 먹되, 3종류의 캔디를 먹고싶다. 캔디의 종류를 나타내는 candyType이 주어질 때, Alice가 먹을 수 있는 캔디의 최대 개수를 반환하라.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Keyboard Row</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_500_keyboard_row/</link>
      <pubDate>Mon, 23 Jan 2023 00:27:27 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_500_keyboard_row/</guid>
      <description>LeetCode(500) - Keyboard Row 문제 string 문자열들의 배열인 words가 주어진다. 일반적인 키보드 배열은 알파벳을 세 줄로 나눌 수 있다. qqwertyuiop가 가장 첫 번째 줄, asdfghjkl가 두 번째 줄 마지막으로 zxcvbnm가 세 번재 줄이다. words를 구성하는 word가, 키보드를 구성하는 세 줄 중 하나의 라인에서 다 완성이 된다면 배열에 삽입하여 해당 배열을 반환하라.
  입력 Input: words = [&amp;quot;Hello&amp;quot;,&amp;quot;Alaska&amp;quot;,&amp;quot;Dad&amp;quot;,&amp;quot;Peace&amp;quot;] 출력 Output: [&amp;quot;Alaska&amp;quot;,&amp;quot;Dad&amp;quot;] 풀이 키보드 배치를 세군데로 나누고, 세 개의 unordered_set을 만들어서 미리 저장한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Longest Palindrome</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_409_longest_palindrome/</link>
      <pubDate>Mon, 16 Jan 2023 23:54:27 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_409_longest_palindrome/</guid>
      <description>LeetCode(409) - Longest Palindrome 문제 문자열 s가 주어진다. 문자열 s의 문자들을 재조합하여 Palidrome을 만들 때 가장 긴 Palidrome의 길이를 반환하라.
입력 Input: s = &amp;quot;abccccdd&amp;quot; 출력 Output: 7 문자열 abccccdd를 재조합해서 가장 큰 길이의 Palidrome을 만들면 dccaccd이므로, 해당 길이인 7을 반환한다.
풀이 unordered_map으로 각 문자들의 출현빈도를 카운팅하고, 짝수 수를 구해 Palidrome을 계산한다. 라고 0. 처럼 생각했는데 짝수를 카운팅 후 Palidrome의 길이를 계산하는 방법을 몰라서 Solution을 보고 같이 map을 써서 본 풀이를 적는다(even이면 전체사이즈를, odd가 1 초과일때 +1 해주면 되는거였다).</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Find the Difference</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_389_find_the_difference/</link>
      <pubDate>Sun, 15 Jan 2023 18:25:02 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_389_find_the_difference/</guid>
      <description>LeetCode(387) - Find the Difference 문제 문자열 s와 t가 주어진다. 문자열 t는 문자열 s를 셔플링하고, 여기에 문자 하나를 추가한 문자열이다. 주어진 문자열 t에서 추가된 문자를 찾아 반환하라.
입력 Input: s = &amp;quot;abcd&amp;quot;, t = &amp;quot;abcde&amp;quot; 출력 Output: &amp;quot;e&amp;quot; 풀이 소문자 알파벳만으로 구성된 문자열이므로, 모든 문자의 출현 빈도를 int[26]으로 해결할 수 있다. int[26] 배열을 s, t용으로 각자 하나씩 만들고, 두 배열을 순회하면서 출현 빈도가 다른 하나의 문자를 반환한다. 문자 계산은 삽입 시 c - &#39;a&#39;로 하여 a는 0 번째 index에 추가되도록 하고, 반환할 때는 index + &#39;a&#39;로 계산하여 index를 알파벳으로 변환한 후 반환한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - First Unique Character in a String</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_387_first_unique_character_in_a_string/</link>
      <pubDate>Sun, 15 Jan 2023 18:01:29 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_387_first_unique_character_in_a_string/</guid>
      <description>LeetCode(387) - First Unique Character in a String 문제 문자열 s가 주어진다. 문자열s를 구성하는 문자 중, 한번만 등장하는 문자를 찾고, 그 중 가장 낮은 index를 가진 문자의 index를 반환하라.
입력 Input: s = &amp;quot;loveleetcode&amp;quot; 출력 Output: 2  문자열 loveleetcode 중 중복되지 않은 문자는 v,t,c,o, 그리고 d 이다. 이 중 가장 낮은 index를 갖는 문자는 v이며, index는 2 이므로, 2를 반환한다.  풀이 문자를 key로 갖고, &amp;lt;int,int&amp;gt; 타입의 pair를 value로 갖는 map을 이용한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Ransom Note</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_383_ransom_note/</link>
      <pubDate>Sat, 14 Jan 2023 20:22:37 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_383_ransom_note/</guid>
      <description>LeetCode(383) - Ransom Note 문제 문자열 ransomNote와 magazine 이 주어진다. ransomNote를 이용해 magazine의 일부를 구성할 수 있다면 true를, 아니라면 false를 반환하라.
 구성에 있어서 순서는 상관이 없다. ransomNote가 aab 이고, magazine이 baa라면, ransomNote의 재배열이 magazine의 일부이므로 true이다.  입력 Input: ransomNote = &amp;quot;aa&amp;quot;, magazine = &amp;quot;aab&amp;quot; 출력 Output: true 풀이 ransomNote를 모두 소비했을 때 magazine의 일부일 경우 true를 반환한다. ransomNote에 있는 문자가 magazine에 없다면 false이다. ransomNote의 문자열을 순회하며 각 문자들을 map에 key로 하고 value는 등장 횟수마다 +1 한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Intersection of Two Arrays II</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_350_intersection_of_two_arrays2/</link>
      <pubDate>Sat, 14 Jan 2023 18:48:45 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_350_intersection_of_two_arrays2/</guid>
      <description>LeetCode(349) - Intersection of Two Arrays II 문제 두 정수 배열 nums1과 nums2가 주어진다. 두 배열에서 공통된 값을 가지는 수의 배열을 반환하라.
 반환되는 배열의 순서는 상관이 없다. 겹치는 값이 여러번이라면, 겹치는 횟수만큼 반환한다.  입력 Input: nums1 = [1,2,2,1], nums2 = [2,2] 출력 Output: [2,2]  nums1에 2 가 두번 존재하고, nums2에도 2가 두 번존재하므로, [2,2]로 반환한다. 만약 nums1에 2가 한 번 등장한다면, 반환은 [2] 이다.  풀이 nums1를 순회하면서 map에 삽입한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Intersection of Two Arrays</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_349_intersection_of_two_arrays/</link>
      <pubDate>Sat, 14 Jan 2023 18:01:03 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_349_intersection_of_two_arrays/</guid>
      <description>LeetCode(349) - Intersection of Two Arrays 문제 두 정수 배열 nums1과 nums2가 주어진다. 두 배열에서 공통된 값을 가지는 수의 배열을 반환하라.
 반환되는 배열의 순서는 상관이 없다. 공통된 값은 중복으로 반환하면 안된다.  입력 Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 출력 Output: [9,4] 풀이 nums1를 순회하면서 map에 삽입한다. nums2를 순회하면서 map에 이미 값이 있는지 확인한다. 값이 있다면 중복된 값이므로 반환될 배열에 삽입한다. 배열은 중복으로 삽입하면 안되므로 이미 값이 존재한다면 무시한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Missing Nuimber</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_268_missing_number/</link>
      <pubDate>Sat, 14 Jan 2023 17:24:09 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_268_missing_number/</guid>
      <description>LeetCode(268) - Missing Number 문제 0 ~ n까지의 수를 가진 배열 nums가 주어진다. nums는 n개의 고유한 수를 가진다. nums에서 누락된 유일한 수 를 반환하라.
입력 Input: nums = [9,6,4,2,3,5,7,0,1] 출력 Output: 8 설명: nums의 크기는 9이며, 이는 9개의 고유한 수를 가진다. 고유한 수는 [0,9] 사이의 값을 가질 수 있다. 8은 이 배열에서 빠져있는 고유한 수이다.
Constraints: n == nums.length 1 &amp;lt;= n &amp;lt;= 104 0 &amp;lt;= nums[i] &amp;lt;= n All the numbers of nums are unique.</description>
    </item>
    
    <item>
      <title>Leetcode 공부 - Valid Anagram</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_242_valid_anagram/</link>
      <pubDate>Sat, 14 Jan 2023 00:06:19 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_242_valid_anagram/</guid>
      <description>LeetCode(242) - Valid Anagram 문제 문자열 s와 t가 주어진다. 두 문자열이 Anagram인지 판단하여 Anagram이면 true를, 아니라면 false를 반환하라.
입력 Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; 출력 Output: true 풀이 s와 t를 정렬하고, 문자열만큼의 길이를 순회하면서 해당 index에 s와 t가 다르다면 false를 반환한다. 문자열 순회가 끝나면 true를 반환한다.  코드 #include&amp;lt;iostream&amp;gt; #include&amp;lt;algorithm&amp;gt; using namespace std; bool isAnagram(string s, string t) { if (s.size() == 0 || t.size() == 0) return false; if (s.</description>
    </item>
    
    <item>
      <title>Leetcode 공부 - Container Duplicate</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_217_contains_duplicate/</link>
      <pubDate>Fri, 13 Jan 2023 23:13:43 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_217_contains_duplicate/</guid>
      <description>LeetCode(217) - Contains Duplicate 문제 정수 배열 nums가 주어진다. 중복된 정수가 배열에 있다면 true를 반환하고 중복이 없다면 false를 반환하라
입력 Input: nums = [1,1,1,3,3,4,3,2,4,2] 출력 Output: true 풀이 배열을 순회하면서 각 값들을 set에 넣는다. set에 현재 배열의 값과 동일한 값이 있다면 중복이므로 true를 반환한다. 배열을 모두 순회했다면 중복이 없으므로 false를 반환한다.  코드 bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_set&amp;lt;int&amp;gt; uset; for(int num : nums) { if(uset.count(num) &amp;gt; 0) { return true; } uset.</description>
    </item>
    
    <item>
      <title>Leetcode 공부 - Majority Element</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_169_majority_element/</link>
      <pubDate>Tue, 10 Jan 2023 23:47:16 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_169_majority_element/</guid>
      <description>LeetCode(169) - Majority Element 문제 n의 길이를 가지는 정수형 배열 nums가 주어진다. nums에 저장된 정수 중 가장 많은 빈도의 정수를 반환하라. 가장 많은 빈도를 갖는 정수는 2/n개 이상이다.
입력 nums = [2,2,1,1,1,2,2] 출력 Output: 2 풀이 key는 정수 값을, value는 정수의 빈도를 나타내는 unordered_map을 사용한다. nums를 순회하면서, 해당 정수의 key를 조회, value의 값을 +1 하여 빈도를 나타낸다. 빈도가 2/n이상이라면 해당 정수가 가장 많은 빈도의 정수이므로, 해당 정수를 반환한다.  코드 class Solution { public: int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_map&amp;lt;int, int&amp;gt; umap; int maxSize = nums.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Intersection of Two Linked Lists</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_160_intersection_of_two_linked_lists/</link>
      <pubDate>Tue, 10 Jan 2023 22:31:16 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_160_intersection_of_two_linked_lists/</guid>
      <description>LeetCode(160) - Intersection of Two Linked Lists 문제 두 Linked List의 headA, headB가 주어진다. 두 List 가 만나는 교차점이 있다면 해당 노드를 반환하고, 두 리스트가 교차하지 않고 평행하다면 null을 반환하라.
입력 Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 skipA, skipB는 주어지는 값이 아닌 설명을 위한 예시이다.
출력 Output: Intersected at &#39;8&#39; 풀이 문제 - Linked List Cycle 와 매우 유사하다. unordered_set을 이용해 ListNode의 고유성을 기준으로 교차점이 있는지 판단한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Linked List Cycle</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_141_linked_list_cycle/</link>
      <pubDate>Tue, 10 Jan 2023 14:50:12 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_141_linked_list_cycle/</guid>
      <description>LeetCode(141) - Linked List Cycle 문제 Linked List의 head가 주어진다. 주어진 Linked List가 cycle을 갖는지 판단하라.
입력 head = [3,2,0,-4], pos = 1 pos는 주어지는 값이 아니고 설명을 돕기위한 예시입니다..
출력 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed). 풀이 ListNode의 포인터는 유니크하므로, 해당 포인터를 set으로 관리하여 중복을 확인한다. ListNode 타입의 unordered_set을 만든다. unordered_set에 현재 ListNode의 포인터가 없다면 현재 노드를 set에 삽입한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Same Tree</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_100_same_tree/</link>
      <pubDate>Mon, 09 Jan 2023 22:30:45 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_100_same_tree/</guid>
      <description>LeetCode(100) - Same Tree 문제 Binary Tree 두 개가 주어진다. 두 Binary Tree가 같은지 비교하여 같다면 True를, 다르다면 False를 반환한다.
입력 root = [1,null,2,3]   출력 [1,3,2] 풀이  주어진 Binary Tree의 root에서 중위순회한다. Inorder traversal은 Bianry Tree에서 좌측 노드를 먼저 순회 후, 자기 자신, 그리고 우측 노드를 탐색하는 방법이다. 주어진 입력에서 root노드는 1, 좌측 노드는 없으므로 자기 자신 1이 먼저 출력되고, 우측 노드로 이동 한다. 우측노드에서는 좌측노드로 이동, 마찬가지고 좌/우 노드가 없으므로 자기 자신이 출력된다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Binary Tree Inorder Traversal</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_94_binary_tree_inorder_traversal/</link>
      <pubDate>Mon, 09 Jan 2023 22:20:19 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_94_binary_tree_inorder_traversal/</guid>
      <description>LeetCode(94) - Binary Tree Inorder Traversal 문제 Binary Tree의 root가 주어진다. Inorder Traversal(중위순회)를 한 결과를 반환하라.
입력 root = [1,null,2,3]   출력 [1,3,2] 풀이  주어진 Binary Tree의 root에서 중위순회한다. Inorder traversal은 Bianry Tree에서 좌측 노드를 먼저 순회 후, 자기 자신, 그리고 우측 노드를 탐색하는 방법이다. 주어진 입력에서 root노드는 1, 좌측 노드는 없으므로 자기 자신 1이 먼저 출력되고, 우측 노드로 이동 한다. 우측노드에서는 좌측노드로 이동, 마찬가지고 좌/우 노드가 없으므로 자기 자신이 출력된다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Merge Sorted Array</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_88_merge_sorted_array/</link>
      <pubDate>Sat, 07 Jan 2023 00:20:44 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_88_merge_sorted_array/</guid>
      <description>LeetCode(88) - Merge Sorted Array 문제 두 개의 오름차순으로 정렬된 정수형 배열 nums1과 nums2가 주어진다. 또한 nums1의 element의 수를 나타내는 m과 nums2의 수를 나타내는 n이 주어진다.
두 배열을 병합하여 오른차순으로 정렬된 배열을 반환하라.
추가적인 배열을 선언하지 않고 nums1에 정렬된 배열을 반환하라.
입력 Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 출력 Output: [1,2,2,3,5,6] 풀이  하나의 배열을 내부적으로 선언하고, 두 배열의 index들을 하나씩 증가하며 새로 선언한 배열 index에 할당한 다음, 입력받은 두 배열을 모두 순회하면 선언한 배열을 nums1이 복사하여 풀 수 있다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Remove Duplicates from Sorted List</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_83_remove_duplicates_from_sorted_list/</link>
      <pubDate>Thu, 08 Dec 2022 23:40:46 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_83_remove_duplicates_from_sorted_list/</guid>
      <description>LeetCode(83) - Remove Duplicates from Sorted List 문제 정수를 포함하는 구조체 리스트가 정렬되어 주어진다. 중복된 노드를 제외한 리스트 head를 반환하라
입력 Input: head = [1,1,2,3,3] 출력 Output: [1,2,3] 풀이  List를 head부터 NULL이 아닐때 까지 순회하면서 현재 노드의 val과 다음 노드의 val이 같다면, cur 노드의 next를 next-&amp;gt;next로 한칸 건너 뛴다. val과 같지 않다면 cur노드는 다음 노드를 가리킨다.  코드 LeetCode에서 바로 실행해서 이번에는 main이 없습니다.
/** * Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>LeetCodee 공부 - Climbing Stairs</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_70_climbing_stairs/</link>
      <pubDate>Thu, 08 Dec 2022 01:41:17 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_70_climbing_stairs/</guid>
      <description>LeetCode(70) - Climbing Stairs 문제 n개의 단이 있는 계단이 있다. 계단을 오르는 방법은 1칸씩 혹은 2칸씩 오르는 방법이 있다. n번째의 계단을 오르는 방법을 몇개나 있는지 반환하라.
입력 Input: n = 3 출력 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step 풀이  풀때마다 항상 어려운 DP(Dynamic Programming)문제다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Sqrt(x)</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_69_sqrt/</link>
      <pubDate>Thu, 08 Dec 2022 01:07:34 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_69_sqrt/</guid>
      <description>LeetCode(69) - Sqrt(x) 문제 양의 정수 x가 주어질 때, x의 제곱근을 반환하라. 반환되는 제곱근은 정수형으로 내림한 값으로 반환하라.
입력 Input: x = 8 출력 Output: 2 풀이  주어진 양의정수에 대해 양의 제곱근을 반환하는 문제다. 정밀하게 구하는 방식은 뉴튼-랩슨법을 써서 많은 연산을 통해 정확도를 높이지만, 문제는 정수를 반환하는 문제다. 주어지는 x가 매우 큰 값일 경우 1씩 더해서 제곱근을 찾기에는 많은 연산을 필요로 한다. 찾는 제곱근은 양의 제곱근이므로, 1부터 시작해서 x까지 연산해야한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Add Binary</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_67_add_binary/</link>
      <pubDate>Thu, 08 Dec 2022 00:25:33 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_67_add_binary/</guid>
      <description>LeetCode(67) - Add Binary 문제 Binary를 나타내는 문자열 s1, s2가 주어질 때 두 Bianry를 합 한 문자열을 반환하라.
입력 Input: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; 출력 Output: &amp;quot;10101&amp;quot; 풀이  두 문자열의 끝에서 부터 0번 째 index 까지 순회한다. 순회하며 각각 i, j위치에 있는 바이너리를 계산한다. i와 j의 값을 carry에 저장하고, carry는 모듈러 연산을 통해 나머지 값을 반환할 string의 첫 번째 위치에 저장한다. carry는 나누기의 몫을 취하고, 해당 값을 유지한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Longest Substring Without Repeating Characters</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_3_longest_substring_without_repeating_characters/</link>
      <pubDate>Mon, 05 Dec 2022 00:01:19 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_3_longest_substring_without_repeating_characters/</guid>
      <description>LeetCode(3) - Longest Substring Without Repeating Characters 문제 문자열 s가 주어질 때, 이 문자열에서 반복되지 않은 문자를 갖는 substring의 길이를 반환하라.
입력 Input: s = &amp;quot;abcabcbb&amp;quot; 출력 Output: 3 풀이  문제 설명은 간단한데 이해가 잘 안된다. 풀어서 써보자면, 문자열 중에서 중복되지 않은 문자들의 최대 길이를 구하는 문제다. 예를들어, 문자열 s = &amp;quot;abcdea&amp;quot;가 있다면, abcde 까지 중복되지 않은 문자열이므로 결과 값은 5 이다. s = &amp;quot;abcdeafg&amp;quot; 라고 하면, 두 번째 index 부터인 &amp;quot;bcdeafg&amp;quot;에는 중복이 없으므로 이 때 반환값은 문자열 길이 7 이다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Add Two Numbers</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_2_add_two_numbers/</link>
      <pubDate>Sun, 04 Dec 2022 22:19:32 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_2_add_two_numbers/</guid>
      <description>LeetCode(67) - Add Two Numbers 문제 Non-empty 정수 Linked list 두 개가 주어진다. 각 list는 정수의 역방향, 즉 가장 낮은 자리수가 첫 번재 위치한다. 각 리스트의 정수를 더 하여 주어진 리스트와 동일하게 가장 낮은 자리 수의 정수가 먼저 오도록 배치된 LinkList를 반환하라.
입력 Input: l1 = [2,4,3], l2 = [5,6,4] 출력 Output: [7,0,8] 풀이  두 리스트를 모두 순회하면서 리스트가 NULL이 아닐 경우, 해당 val값을 sum 변수에 합한다. carry가 발생할 경우를 고려한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Plus One</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_66_plus_one/</link>
      <pubDate>Sun, 04 Dec 2022 21:02:51 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_66_plus_one/</guid>
      <description>LeetCode(66) - Plus One 문제 정수를 표현하는 vector&amp;lt;int&amp;gt; digits가 주어진다. digits는 배열로 이루어져 있지만, 정수를 표현한다. 예를들어 [3,2,1] 배열인 경우, 정수 321을 나타낸다. 주어진 digits배열에 +1 한 값을 vector&amp;lt;int&amp;gt;형태로 반환하라.
입력 Input: digits = [4,3,2,1] 출력 Output: [4,3,2,2] 풀이  맨 마지막 정수 값에 +1을 할 수 있겠으나&amp;hellip; carry로 인한 자리수가 변경될 수 있고, 이를 위해서 예외처리가 많아질것 같다. 배열을 정수로 변환하고, 정수를 배열로 변환하도록 한다. &amp;hellip;라고 생각했으나, 자리수가 100자리까지 나오는데 100자리수를 정수형으로 저장할 수 없다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Length of Last Word</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_58_length_of_last_word/</link>
      <pubDate>Sun, 04 Dec 2022 20:43:20 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_58_length_of_last_word/</guid>
      <description>LeetCode(59) - Length of Last Word 문제 단어와 공백으로 이루어진 문자열 s가 주어진다. 마지막 단어의 철자 개수를 반환하라.
입력 Input: s = &amp;quot;luffy is still joyboy&amp;quot; 출력 Output: 6 풀이  string s는 문자와 공백만으로 이루어져 있으므로, string의 맨 뒷 부분 부터 검사하여 문자를 카운트 후 문자 수를 반환한다.  코드 Visual studio에서 바로 실행하도록 임의의 main문을 함께 첨부합니다. lengthOfLastWord()만 보시면 됩니다.
#include&amp;lt;iostream&amp;gt; using namespace std; int lengthOfLastWord(string s) { int count = 0; for (int i = s.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Search Insert Position</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_35_search_insert_position/</link>
      <pubDate>Sun, 04 Dec 2022 19:44:43 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_35_search_insert_position/</guid>
      <description>LeetCode(35) - Search Insert Position 문제 중복을 허용하지 않는 정렬된 integer nums와 integer type의 target이 주어진다. nums배열에서 target을 발견한다면 target이 위치한 index를 반환한다. target을 찾지 못하였다면 target이 포함될 index를 반환한다. time complexity는 O(log n)을 만족해야 한다.
입력  Input: nums = [1,3,5,6], target = 7 출력 Output: 4 풀이  O(log n) 의 조건이 없다면, 정렬된 배열이므로 for loop으로 한번 배열을 순회하면 답을 찾을 수 있다. 하지만 이 경우 Time complexity는 O(n) 이므로 사용할 수 없다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Remove Element</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_27_remove_element/</link>
      <pubDate>Sun, 04 Dec 2022 19:26:04 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_27_remove_element/</guid>
      <description>LeetCode(27) - Remove Element 문제 중복이 허용되며, 정렬되지 않은 integer 배열 nums와 val가 주어진다. nums에서 val가 제거된 배열을 반환한다. 추가적인 array 할당은 할 수 없으며, in-place로 수정한다.
입력  nums = [0,1,2,2,3,0,4,2], val = 2 출력 5, nums = [0,1,4,0,3,_,_,_] 풀이  문제 26과 유사한 내용이다. 전체 배열을 순회하면서 val와 다른 값이라면 count index에 현재 값을 저장한다. 정렬되지 않은 값이라고 하더라도, count index로 in-place에 저장된 값들은 이미 val과 비교된 값이므로, 현재 element와 비교만 하면 된다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Remove Duplicates from Sorted Array</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_26_remove_duplicates_from_sorted_array/</link>
      <pubDate>Sun, 04 Dec 2022 19:12:59 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_26_remove_duplicates_from_sorted_array/</guid>
      <description>LeetCode(26) - Remove Duplicates from Sorted Array 문제 중복이 허용된 integer type의 오름처순 배열에서, 중복된 값들을 제거한 sorted array를 만들고, 중복을 제외한 원소의 개수를 반환하라.
입력 nums = [0,0,1,1,1,2,2,3,3,4] 출력 5, nums = [0,1,2,3,4,_,_,_,_,_] 풀이  추가적인 배열을 할당하지 않고, 주어진 vector&amp;lt;int&amp;gt;를 수정할 것. 그리고 반환하는 원소의 개수 이후의 nums index는 don&amp;rsquo;t care 한다. 주어진 배열을 마사지 해서 반환해야 하므로, 배열을 순회하면서 배열의 값을 바꿔야 한다. 처음 접근은 다음과 같이 진행하였다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Merge Two Sorted Lists</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_21_merge_two_sorted_lists/</link>
      <pubDate>Thu, 01 Dec 2022 23:38:10 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_21_merge_two_sorted_lists/</guid>
      <description>LeetCode(21) - Merge Two Sorted Lists 문제 두 Linked List의 header가 주어진다. 두 리스트를 정렬하여 하나의 리스트로 반환하라.
입력 list1 = [1,2,4], list2 = [1,3,4] 출력 [1,1,2,3,4,4] 풀이  두 리스트를 순회하면서 작은값을 취하고, 취한 리스트는 다음 노드로 이동하여 두 리스트가 모두 NULL일 때 까지 순회한다. 두 리스트는 모두 정렬된 상태이므로, 함수 도입부에서 한 리스트가 NULL이라면 다른 리스트를 반환한다. 두 리스트 모두 NULL인 경우가 있어서 헷갈렸는데, list1이 NULL일 경우 NULL인 list2를 리턴해도 무방했다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Valid Parentheses</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_20_valid_parentheses/</link>
      <pubDate>Thu, 01 Dec 2022 23:05:08 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_20_valid_parentheses/</guid>
      <description>LeetCode(20) - Valid Parentheses 문제 소괄호, 중괄호, 대괄호로 이루어진 문자열이 주어진다. 이 문자열의 괄호들이 알맞은 pair라면 true를, 아니라면 false를 반환한다.
입력  s = &amp;quot;()[]{}&amp;quot; 출력 true 풀이  전형적인 stack문제로, 괄호가 닫힐때 마다 pair를 확인한다. 주어진 문자열의 문자들을 순회하면서 문자가 여는괄호면 stack에 쌓고, 닫는 괄호라면, 현재 stack에서 top()과 pair비교 후 pair라면 pop을, 아니면 false를 리턴한다.  코드 Visual studio에서 바로 실행하도록 임의의 main문을 함께 첨부합니다. isValid()만 보시면 됩니다.
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;stack&amp;gt; using namespace std; bool isValid(string s) { stack&amp;lt;char&amp;gt; st; for (char c : s) { if (c == &#39;(&#39; || c == &#39;{&#39; || c == &#39;[&#39;) { st.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Longest Common Prefix</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_14_longest_common_prefix/</link>
      <pubDate>Thu, 01 Dec 2022 22:37:08 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_14_longest_common_prefix/</guid>
      <description>LeetCode(14) - Longest Common Prefix 문제 문자열 배열이 주어진다. 이 문자열 배열에서 문자가 공통인 부분만큼 문자열로 반환하라.
입력 strs = [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] 출력 &amp;quot;fl&amp;quot; 풀이  문자열들을 사전순으로 정렬하고, 첫 번째 문자열을 기준으로 비교하여 같은 문자라면 index를 순차적으로 증가시킨다. 문자가 같을 때 까지 증가하다가 다른 문자가 나오면 기존까지 저장한 문자열을 반환한다.  코드 string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) { vector&amp;lt;string&amp;gt; s = strs; sort(s.begin(), s.end()); string ret = &amp;quot;&amp;quot;; string pilot = s.at(0); for (int i = 0; i &amp;lt; pilot.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Palindrome Number</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_9_palindrome_number/</link>
      <pubDate>Thu, 01 Dec 2022 00:27:00 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_9_palindrome_number/</guid>
      <description>LeetCode(9) - Palindrome Number 문제 integer x가 주어질 때, x가 Palindrome(회문)을 만족하면 true를 return, 아니라면 false를 리턴
입력 x = 121 출력 true 풀이  입력 x를 string으로 변환 앞부분을 가르키는 index front와 뒷부분을 가르키는 index back을 만들어 앞부분은 증가를, 뒷부분은 감소하며 전체 string 비교 front가 back보다 커질 때 까지 비교하여 front가 back보다 커진다면 회문으로 판단, 순회를 종료하고 true반환. 비교 중 다른 값이 나온다면 곧바로 false반환  코드 class Solution { public: bool isPalindrome(int x) { string s = to_string(x); int front = 0, back = s.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Two Sum</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_1_two_some/</link>
      <pubDate>Wed, 30 Nov 2022 23:23:39 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_1_two_some/</guid>
      <description>LeetCode(1) - Two Sum 문제 integer 배열과 target이 주어질 때, 배열에서 두 정수의 합이 target을 만족하는 두 index를 반환
입력 nums = [2,7,11,15], target = 9 출력 [0,1] 풀이  배열 순회 중 현재 배열의 값과 target과의 diff 값이 hash table에 있으면, diff key의 value와 현재 배열 index를 리턴. hash table에 diff값이 없으면, 현재 배열 index의 value를 key로, index를 value로 table에 저장. 배열 순회.  코드 class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { unordered_map&amp;lt;int, int&amp;gt; umap; vector&amp;lt;int&amp;gt; ret; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
  </channel>
</rss>
