<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Moo-woong</title>
    <link>https://moo-woong.github.io/posts/</link>
    <description>Recent content in Posts on Moo-woong</description>
    <image>
      <url>https://moo-woong.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://moo-woong.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 03 Jan 2023 21:25:33 +0900</lastBuildDate><atom:link href="https://moo-woong.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Dev/Infra] XXX is not in the sudoers file.  This incident will be reported.</title>
      <link>https://moo-woong.github.io/posts/dev_env/sudoers_permission/</link>
      <pubDate>Tue, 03 Jan 2023 21:25:33 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/dev_env/sudoers_permission/</guid>
      <description>XXX is not in the sudoers file. This incident will be reported. Ubuntu, CentOS 등 리눅스 환경을 새로 설치하면 만나는 오류. 개발 툴을 설정하기 위해 유틸들을 설치할때 sudo를 사용하다 마주하게 된다.
XXX is not in the sudoers file. This incident will be reported. 원인 현재 접속중인 계정이 sudoers에 등록되지 않아 발생한다. sudoers파일에 현재 계정을 등록하여 sudo권한을 주자.
 sudo의 뜻은? &amp;ldquo;super user do&amp;rdquo;.
  su 뜻은? &amp;ldquo;super user&amp;rdquo;
 해결법  su 명령어로 root계정으로 전환  [hugh@localhost ~]$ su Password: #비밀번호 입력 [root@localhost hugh]# [root@localhost hugh]# /etc/sudoers 파일에서 현재 계정을 추가   99 ## Allow root to run any commands anywhere 100 root ALL=(ALL) ALL 101 hugh ALL=(ALL) ALL # &amp;lt;-- sudo권한이 필요한 계정 추가 root계정에서 로그아웃하고 추가한 계정에서 sudo권한이 필요한 명령어 수행  [root@localhost hugh]# exit exit [hugh@localhost ~]$ [hugh@localhost ~]$ [hugh@localhost ~]$ sudo yum install -y vim [sudo] password for hugh: Loaded plugins: fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: mirror.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Remove Duplicates from Sorted List</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_83_remove_duplicates_from_sorted_list/</link>
      <pubDate>Thu, 08 Dec 2022 23:40:46 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_83_remove_duplicates_from_sorted_list/</guid>
      <description>LeeCode(83) - Remove Duplicates from Sorted List 문제 정수를 포함하는 구조체 리스트가 정렬되어 주어진다. 중복된 노드를 제외한 리스트 head를 반환하라
입력 Input: head = [1,1,2,3,3] 출력 Output: [1,2,3] 풀이  List를 head부터 NULL이 아닐때 까지 순회하면서 현재 노드의 val과 다음 노드의 val이 같다면, cur 노드의 next를 next-&amp;gt;next로 한칸 건너 뛴다. val과 같지 않다면 cur노드는 다음 노드를 가리킨다.  코드 LeetCode에서 바로 실행해서 이번에는 main이 없습니다.
/** * Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>LeeCode 공부 - Climbing Stairs</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_70_climbing_stairs/</link>
      <pubDate>Thu, 08 Dec 2022 01:41:17 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_70_climbing_stairs/</guid>
      <description>LeeCode(70) - Climbing Stairs 문제 n개의 단이 있는 계단이 있다. 계단을 오르는 방법은 1칸씩 혹은 2칸씩 오르는 방법이 있다. n번째의 계단을 오르는 방법을 몇개나 있는지 반환하라.
입력 Input: n = 3 출력 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step 풀이  풀때마다 항상 어려운 DP(Dynamic Programming)문제다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Sqrt(x)</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_69_sqrt/</link>
      <pubDate>Thu, 08 Dec 2022 01:07:34 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_69_sqrt/</guid>
      <description>LeeCode(69) - Sqrt(x) 문제 양의 정수 x가 주어질 때, x의 제곱근을 반환하라. 반환되는 제곱근은 정수형으로 내림한 값으로 반환하라.
입력 Input: x = 8 출력 Output: 2 풀이  주어진 양의정수에 대해 양의 제곱근을 반환하는 문제다. 정밀하게 구하는 방식은 뉴튼-랩슨법을 써서 많은 연산을 통해 정확도를 높이지만, 문제는 정수를 반환하는 문제다. 주어지는 x가 매우 큰 값일 경우 1씩 더해서 제곱근을 찾기에는 많은 연산을 필요로 한다. 찾는 제곱근은 양의 제곱근이므로, 1부터 시작해서 x까지 연산해야한다.</description>
    </item>
    
    <item>
      <title>LeeCode 공부 - Add Binary</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_67_add_binary/</link>
      <pubDate>Thu, 08 Dec 2022 00:25:33 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_67_add_binary/</guid>
      <description>LeeCode(67) - Add Binary 문제 Binary를 나타내는 문자열 s1, s2가 주어질 때 두 Bianry를 합 한 문자열을 반환하라.
입력 Input: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; 출력 Output: &amp;quot;10101&amp;quot; 풀이  두 문자열의 끝에서 부터 0번 째 index 까지 순회한다. 순회하며 각각 i, j위치에 있는 바이너리를 계산한다. i와 j의 값을 carry에 저장하고, carry는 모듈러 연산을 통해 나머지 값을 반환할 string의 첫 번째 위치에 저장한다. carry는 나누기의 몫을 취하고, 해당 값을 유지한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Longest Substring Without Repeating Characters</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_3_longest_substring_without_repeating_characters/</link>
      <pubDate>Mon, 05 Dec 2022 00:01:19 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_3_longest_substring_without_repeating_characters/</guid>
      <description>LeeCode(3) - Longest Substring Without Repeating Characters 문제 문자열 s가 주어질 때, 이 문자열에서 반복되지 않은 문자를 갖는 substring의 길이를 반환하라.
입력 Input: s = &amp;quot;abcabcbb&amp;quot; 출력 Output: 3 풀이  문제 설명은 간단한데 이해가 잘 안된다. 풀어서 써보자면, 문자열 중에서 중복되지 않은 문자들의 최대 길이를 구하는 문제다. 예를들어, 문자열 s = &amp;quot;abcdea&amp;quot;가 있다면, abcde 까지 중복되지 않은 문자열이므로 결과 값은 5 이다. s = &amp;quot;abcdeafg&amp;quot; 라고 하면, 두 번째 index 부터인 &amp;quot;bcdeafg&amp;quot;에는 중복이 없으므로 이 때 반환값은 문자열 길이 7 이다.</description>
    </item>
    
    <item>
      <title>LeeCode 공부 - Add Two Numbers</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_2_add_two_numbers/</link>
      <pubDate>Sun, 04 Dec 2022 22:19:32 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_2_add_two_numbers/</guid>
      <description>LeeCode(67) - Add Two Numbers 문제 Non-empty 정수 Linked list 두 개가 주어진다. 각 list는 정수의 역방향, 즉 가장 낮은 자리수가 첫 번재 위치한다. 각 리스트의 정수를 더 하여 주어진 리스트와 동일하게 가장 낮은 자리 수의 정수가 먼저 오도록 배치된 LinkList를 반환하라.
입력 Input: l1 = [2,4,3], l2 = [5,6,4] 출력 Output: [7,0,8] 풀이  두 리스트를 모두 순회하면서 리스트가 NULL이 아닐 경우, 해당 val값을 sum 변수에 합한다. carry가 발생할 경우를 고려한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Plus One</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_66_plus_one/</link>
      <pubDate>Sun, 04 Dec 2022 21:02:51 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_66_plus_one/</guid>
      <description>LeeCode(66) - Plus One 문제 정수를 표현하는 vector&amp;lt;int&amp;gt; digits가 주어진다. digits는 배열로 이루어져 있지만, 정수를 표현한다. 예를들어 [3,2,1] 배열인 경우, 정수 321을 나타낸다. 주어진 digits배열에 +1 한 값을 vector&amp;lt;int&amp;gt;형태로 반환하라.
입력 Input: digits = [4,3,2,1] 출력 Output: [4,3,2,2] 풀이  맨 마지막 정수 값에 +1을 할 수 있겠으나&amp;hellip; carry로 인한 자리수가 변경될 수 있고, 이를 위해서 예외처리가 많아질것 같다. 배열을 정수로 변환하고, 정수를 배열로 변환하도록 한다. &amp;hellip;라고 생각했으나, 자리수가 100자리까지 나오는데 100자리수를 정수형으로 저장할 수 없다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Length of Last Word</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_58_length_of_last_word/</link>
      <pubDate>Sun, 04 Dec 2022 20:43:20 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_58_length_of_last_word/</guid>
      <description>LeeCode(59) - Length of Last Word 문제 단어와 공백으로 이루어진 문자열 s가 주어진다. 마지막 단어의 철자 개수를 반환하라.
입력 Input: s = &amp;quot;luffy is still joyboy&amp;quot; 출력 Output: 6 풀이  string s는 문자와 공백만으로 이루어져 있으므로, string의 맨 뒷 부분 부터 검사하여 문자를 카운트 후 문자 수를 반환한다.  코드 Visual studio에서 바로 실행하도록 임의의 main문을 함께 첨부합니다. lengthOfLastWord()만 보시면 됩니다.
#include&amp;lt;iostream&amp;gt; using namespace std; int lengthOfLastWord(string s) { int count = 0; for (int i = s.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Search Insert Position</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_35_search_insert_position/</link>
      <pubDate>Sun, 04 Dec 2022 19:44:43 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_35_search_insert_position/</guid>
      <description>LeeCode(35) - Search Insert Position 문제 중복을 허용하지 않는 정렬된 integer nums와 integer type의 target이 주어진다. nums배열에서 target을 발견한다면 target이 위치한 index를 반환한다. target을 찾지 못하였다면 target이 포함될 index를 반환한다. time complexity는 O(log n)을 만족해야 한다.
입력  Input: nums = [1,3,5,6], target = 7 출력 Output: 4 풀이  O(log n) 의 조건이 없다면, 정렬된 배열이므로 for loop으로 한번 배열을 순회하면 답을 찾을 수 있다. 하지만 이 경우 Time complexity는 O(n) 이므로 사용할 수 없다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Remove Element</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_27_remove_element/</link>
      <pubDate>Sun, 04 Dec 2022 19:26:04 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_27_remove_element/</guid>
      <description>LeeCode(27) - Remove Element 문제 중복이 허용되며, 정렬되지 않은 integer 배열 nums와 val가 주어진다. nums에서 val가 제거된 배열을 반환한다. 추가적인 array 할당은 할 수 없으며, in-place로 수정한다.
입력  nums = [0,1,2,2,3,0,4,2], val = 2 출력 5, nums = [0,1,4,0,3,_,_,_] 풀이  문제 26과 유사한 내용이다. 전체 배열을 순회하면서 val와 다른 값이라면 count index에 현재 값을 저장한다. 정렬되지 않은 값이라고 하더라도, count index로 in-place에 저장된 값들은 이미 val과 비교된 값이므로, 현재 element와 비교만 하면 된다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Remove Duplicates from Sorted Array</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_26_remove_duplicates_from_sorted_array/</link>
      <pubDate>Sun, 04 Dec 2022 19:12:59 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_26_remove_duplicates_from_sorted_array/</guid>
      <description>LeeCode(26) - Remove Duplicates from Sorted Array 문제 중복이 허용된 integer type의 오름처순 배열에서, 중복된 값들을 제거한 sorted array를 만들고, 중복을 제외한 원소의 개수를 반환하라.
입력 nums = [0,0,1,1,1,2,2,3,3,4] 출력 5, nums = [0,1,2,3,4,_,_,_,_,_] 풀이  추가적인 배열을 할당하지 않고, 주어진 vector&amp;lt;int&amp;gt;를 수정할 것. 그리고 반환하는 원소의 개수 이후의 nums index는 don&amp;rsquo;t care 한다. 주어진 배열을 마사지 해서 반환해야 하므로, 배열을 순회하면서 배열의 값을 바꿔야 한다. 처음 접근은 다음과 같이 진행하였다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Merge Two Sorted Lists</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_21_merge_two_sorted_lists/</link>
      <pubDate>Thu, 01 Dec 2022 23:38:10 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_21_merge_two_sorted_lists/</guid>
      <description>LeeCode(21) - Merge Two Sorted Lists 문제 두 Linked List의 header가 주어진다. 두 리스트를 정렬하여 하나의 리스트로 반환하라.
입력 list1 = [1,2,4], list2 = [1,3,4] 출력 [1,1,2,3,4,4] 풀이  두 리스트를 순회하면서 작은값을 취하고, 취한 리스트는 다음 노드로 이동하여 두 리스트가 모두 NULL일 때 까지 순회한다. 두 리스트는 모두 정렬된 상태이므로, 함수 도입부에서 한 리스트가 NULL이라면 다른 리스트를 반환한다. 두 리스트 모두 NULL인 경우가 있어서 헷갈렸는데, list1이 NULL일 경우 NULL인 list2를 리턴해도 무방했다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Valid Parentheses</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_20_valid_parentheses/</link>
      <pubDate>Thu, 01 Dec 2022 23:05:08 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_20_valid_parentheses/</guid>
      <description>LeeCode(20) - Valid Parentheses 문제 소괄호, 중괄호, 대괄호로 이루어진 문자열이 주어진다. 이 문자열의 괄호들이 알맞은 pair라면 true를, 아니라면 false를 반환한다.
입력  s = &amp;quot;()[]{}&amp;quot; 출력 true 풀이  전형적인 stack문제로, 괄호가 닫힐때 마다 pair를 확인한다. 주어진 문자열의 문자들을 순회하면서 문자가 여는괄호면 stack에 쌓고, 닫는 괄호라면, 현재 stack에서 top()과 pair비교 후 pair라면 pop을, 아니면 false를 리턴한다.  코드 Visual studio에서 바로 실행하도록 임의의 main문을 함께 첨부합니다. isValid()만 보시면 됩니다.
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;stack&amp;gt; using namespace std; bool isValid(string s) { stack&amp;lt;char&amp;gt; st; for (char c : s) { if (c == &#39;(&#39; || c == &#39;{&#39; || c == &#39;[&#39;) { st.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Longest Common Prefix</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_14_longest_common_prefix/</link>
      <pubDate>Thu, 01 Dec 2022 22:37:08 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_14_longest_common_prefix/</guid>
      <description>LeeCode(14) - Longest Common Prefix 문제 문자열 배열이 주어진다. 이 문자열 배열에서 문자가 공통인 부분만큼 문자열로 반환하라.
입력 strs = [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] 출력 &amp;quot;fl&amp;quot; 풀이  문자열들을 사전순으로 정렬하고, 첫 번째 문자열을 기준으로 비교하여 같은 문자라면 index를 순차적으로 증가시킨다. 문자가 같을 때 까지 증가하다가 다른 문자가 나오면 기존까지 저장한 문자열을 반환한다.  코드 string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) { vector&amp;lt;string&amp;gt; s = strs; sort(s.begin(), s.end()); string ret = &amp;quot;&amp;quot;; string pilot = s.at(0); for (int i = 0; i &amp;lt; pilot.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Palindrome Number</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_9_palindrome_number/</link>
      <pubDate>Thu, 01 Dec 2022 00:27:00 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_9_palindrome_number/</guid>
      <description>LeeCode(9) - Palindrome Number 문제 integer x가 주어질 때, x가 Palindrome(회문)을 만족하면 true를 return, 아니라면 false를 리턴
입력 x = 121 출력 true 풀이  입력 x를 string으로 변환 앞부분을 가르키는 index front와 뒷부분을 가르키는 index back을 만들어 앞부분은 증가를, 뒷부분은 감소하며 전체 string 비교 front가 back보다 커질 때 까지 비교하여 front가 back보다 커진다면 회문으로 판단, 순회를 종료하고 true반환. 비교 중 다른 값이 나온다면 곧바로 false반환  코드 class Solution { public: bool isPalindrome(int x) { string s = to_string(x); int front = 0, back = s.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Two Sum</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_1_two_some/</link>
      <pubDate>Wed, 30 Nov 2022 23:23:39 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_1_two_some/</guid>
      <description>LeeCode(1) - Two Sum 문제 integer 배열과 target이 주어질 때, 배열에서 두 정수의 합이 target을 만족하는 두 index를 반환
입력 nums = [2,7,11,15], target = 9 출력 [0,1] 풀이  배열 순회 중 현재 배열의 값과 target과의 diff 값이 hash table에 있으면, diff key의 value와 현재 배열 index를 리턴. hash table에 diff값이 없으면, 현재 배열 index의 value를 key로, index를 value로 table에 저장. 배열 순회.  코드 class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { unordered_map&amp;lt;int, int&amp;gt; umap; vector&amp;lt;int&amp;gt; ret; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>Ubuntu에 Minikube 설치하기</title>
      <link>https://moo-woong.github.io/posts/kubernetes/minikube/</link>
      <pubDate>Tue, 01 Nov 2022 22:54:51 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/minikube/</guid>
      <description>Minikube 설치 Kubernetes 학습을 위해서 환경이 필요하게 되었습니다. 개인 학습을 위해서는 Vanilla k8s, Amazon EKS, 그리고 Minikube 등 다양한 학습환경이 있습니다. 저는 Minikube로 선택했습니다. 이유는 다음과 같습니다.
 Vanilla k8s는 환경설정에 많은 리소스도 필요하고 회사에서 proxy환경에서 설치하는데 애를 많이 먹은 기억이 있어서 환경설정에 많은 시간을 할애하기 싫었습니다. Amazon EKS는 간단하게 구축이 가능하지만 약간의 비용이 발생할 수 있다는 점, 그리고 지지고 볶고 뜯고 맛보고 즐겨야하는데 EKS에서는 잘 할 수 있을까?에 대한 의구심이 있어 Amazon EKS 사용은 나중으로 미뤘습니다.</description>
    </item>
    
    <item>
      <title>Github Blog와 Hugo로 블로그 개설하기</title>
      <link>https://moo-woong.github.io/posts/2022-10-17-github-hugo/</link>
      <pubDate>Sun, 16 Oct 2022 08:15:52 -0700</pubDate>
      
      <guid>https://moo-woong.github.io/posts/2022-10-17-github-hugo/</guid>
      <description>GitHub Blog와 Hugo로 블로그 만들기 개요 회사만 다니다보니 이 핑계, 저 핑계를 대며 개인업무 역량관리에 소홀한게 느껴졌습니다. 과거에도 공부할 때 하나하나 PPT자료를 만들며 체득했던 전공 공부, 정보들은 저한테는 좋은 경험이었습니다. 이에 대한 경험으로 블로그를 만들어 공부도 하고, 정리한 정보들을 공유하여 찾아오는 분들에게 득이되도록 하고 싶어 블로그를 만들어보게 되었습니다. 앞으로도 잘 부탁드리며 블로그 구축부터 정리해보겠습니다.
환경  Blog: Github + Hugo Host machine: Ubuntu 20.04 LTS + VMWare workstation 16 Editor: VS Code on Windows  환경 선택에 대해서는 특별한 이유는 없습니다.</description>
    </item>
    
  </channel>
</rss>
