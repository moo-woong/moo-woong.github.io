<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Moo-woong</title>
    <link>https://moo-woong.github.io/</link>
    <description>Recent content on Moo-woong</description>
    <image>
      <url>https://moo-woong.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://moo-woong.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 12 Feb 2024 03:54:47 +0000</lastBuildDate><atom:link href="https://moo-woong.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kubernetes Study 21 Test</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-21-test/</link>
      <pubDate>Mon, 12 Feb 2024 03:54:47 +0000</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-21-test/</guid>
      <description>#test22</description>
    </item>
    
    <item>
      <title>Kubernetes Study 20 Test</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-20-test/</link>
      <pubDate>Mon, 12 Feb 2024 03:53:44 +0000</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-20-test/</guid>
      <description>#Test21</description>
    </item>
    
    <item>
      <title>Kubernetes Study 17 Test</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-17-test/</link>
      <pubDate>Mon, 12 Feb 2024 03:44:50 +0000</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-17-test/</guid>
      <description>#Test17</description>
    </item>
    
    <item>
      <title>[Kubernetes Study] DaemonSets</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-13-daemonset/</link>
      <pubDate>Tue, 30 Jan 2024 18:29:02 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-13-daemonset/</guid>
      <description>DaemonSet DaemonSet는 Deployment와 유사한 object로 여러 여러 pod들의 집합이다. 하지만 가장 큰 차이는 Pod instance는 노드 별 하나만 설치된다는 점이다. 이는 새로운 노드가 클러스터에 추가되는 것도 포함하며, 신규 노드가 join 시 Daemon Sets는 해당 Pod를 노드에 추가한다.
위와 같은 특징으로 Daemon Sets는 각 노드별로 배치되어야 하는 기능에 사용 가능하다. 예를 들면 노드 별 네트워크 I/O를 모니터링 하는 agent들을 배치할 수 있다. 이처럼 노드 별 agent가 필요로 하는 서비스를 배치한다면 centralized service에서는 노드의 추가, 삭제등의 동작을 DaemonSet에 일임할 수 있다.</description>
    </item>
    
    <item>
      <title>[Kubernetes Study] Resource requirements and limits</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-12-resource-requirements/</link>
      <pubDate>Tue, 30 Jan 2024 18:15:02 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-12-resource-requirements/</guid>
      <description>Resource requirements and limits 각 노드는 CPU와 Memory 리소스를 갖고 있다. 스케쥴러에 이해 Pod가 배치될 때, Pod의 리소스 요청 사항과 노드의 리소스 사용량은 스케쥴링에 직접적인 영향을 미친다.
Requests 사용법 다음과 같이 spec.containers.resources.requests 를 이용해 Pod에 리소스 정보를 명세할 수 있다.
apiVersion:v1kind:Podmetadata:name:simple-webapp-colorlabels:name:simple-webapp-colorspec:containers:- name:simple-webapp-colorimage:simple-webapp-colorports:- containerPort:8080resources:requests:memory:&amp;#34;4Gi&amp;#34;cpu:2단위 CPU CPU의 단위는 정수, 소수점, m 을 이용해서 설정할 수 있다. m은 milli의 뜻으로 1/1000이라서 cpu 0.1은 100m과 동일하며, 1은 1000m과 동일하다.
CPU의 최소 단위는 1m이며 그 이하는 될 수 없다.</description>
    </item>
    
    <item>
      <title>[Kubernetes Study] Taints Tolerations</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-11-taints-tolerations/</link>
      <pubDate>Tue, 30 Jan 2024 00:00:26 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-11-taints-tolerations/</guid>
      <description>Taints and Tolerations 개념 본 포스트에서 사용되는 예시들은 Security나 Intrusion 설정이 되지 않은 것으로 간주한다.
Taint와 Tolerations는 Label과 Selector와 유사하다. Label과 Selector는 필터링과 필터링을 이용한 객체들간의 매핑과 관련되었다면, Taint와 Tolerations는 Pod가 노드에 배치 될 때 제약사항을 만드는 것이다.
예시 관리자가 Pod 배치를 요청하면, 쿠버네티스 스케쥴러는 노드 중 가용 가능한 노드에 Pod를 배치하려 할 것이다. 만약 제약사항이 없다면 스케쥴러는 균등하게 Pod들을 노드에 배치할 것이다.
클러스터에 노드가 3개 있으며, 그 중 A라는 노드는 특정 목적을 위해 사용되는 노드라고 가정해보자.</description>
    </item>
    
    <item>
      <title>[Kubernetes Study] Labelselector</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-10-labelselector/</link>
      <pubDate>Mon, 29 Jan 2024 23:42:35 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-10-labelselector/</guid>
      <description>Label selector kubectl의 --seletor 옵션을 이용해서 필터링을 직접 가능하다
apiVersion:v1kind:Podmetadata:name:simple-webapplabels:app:App1function:Front-end......spec:containers:- name:simple-webappimage:siple-webappports:- containerPort:8080kubectl get pods --selector app=App1 Label은 ReplicaSet, Pod, Service 등 다른 객체들 간의 연결에도 사용할 수 있다. 다음의 ReplicaSet의 예제다.
apiVersion:v1kind:ReplicaSetmetadata:name:simple-webapplabels:app:App1function:Front-endspec:replicas:3selector:matchLabels:app:App1template:metadata:labels:app:App1function:Front-endspec:containers:- name:simple-webappimage:simple-webappmetadata.labels는 ReplicaSet에 할당되는 Label이다. spec.selector.matchLabels는 ReplicaSet과 매치되는 Pod를 지정한다. 위 yaml파일이 실행되면, ReplicaSet과 Pod가 연결된다.
ReplicaSet과 Pod를 연결한 것과 같이 Service와 Pod를 연결할 수도 있다.
apiVersion:v1kind:Servicemetadata:name:my-servicespec:selector:app:App1ports:- protocol:TCPport:80targetPort 9376위처럼 spec.selector를 이용해 Service와 연결된 Pod를 특정할 수 있다.
Annotations annotation은 객체에 추가적인 정보를 입력할 때 사용된다.</description>
    </item>
    
    <item>
      <title>Kubernetes Raspberry Pi</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-raspberry-pi/</link>
      <pubDate>Sun, 10 Sep 2023 15:17:57 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-raspberry-pi/</guid>
      <description>라즈베리파이로 Kubernetes 클러스터 구축하기 회사에서 동일한 구글계정을 사용해서 그런지 유튜브에 Satisfying 비디오로 서버실 선정리, 라즈베리파이로 쿠버네티스 구축하기 등 영상들이 올라왔다. 신기하네, 재밌네 로 끝났었는데 한 한국인 블로거가 빠른 실행력으로 라즈베리파이로 클러스터를 구축한 포스트를 보고 나도 하기로 마음먹었다.
https://www.binaryflavor.com/raspberry-pi-kubernetes-1/
구성 환경 구성
 라즈베링파이4 모델B 4GB 메모리, 128GB SD Card * 4대 L2용 8포트 iptime공유기  라즈베리파이는 6대를 준비하였으나, 2대는 추후에 master node, worker node추가 실습용으로 남겨두고, 1대의 마스터노드, 3대의 워크노드로 클러스터를 구축하기로 했다.</description>
    </item>
    
    <item>
      <title>LeetCode - Jewels and Stones </title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_771/</link>
      <pubDate>Sun, 05 Feb 2023 15:52:48 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_771/</guid>
      <description>LeetCode(771) - Jewels and Stones 문제 문자열 jewels와 stones가 주어진다. stones는 내가 가지고 있는 동의 종류들이고, jewels는 보석의 종류들이다. 내가 가지고 있는 돌들 중 보석이 몇개인지 반환하라.
입력 Input: jewels = &amp;quot;aA&amp;quot;, stones = &amp;quot;aAAbbbb&amp;quot; 출력 Output: 3 설명 stones는 중복이 가능하다. stones와 jewels의 각 문자는 대소문자가 구분된다.  풀이 stones를 순회하며 각 문자들을 map의 key로, 등장 횟수를 value로 저장한다. jewels를 순회하며 각 문자들을 map에서 검색 후 등장횟수들을 모두 카운트 후 반환한다.</description>
    </item>
    
    <item>
      <title>LeetCode - Degree of an Array</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_697/</link>
      <pubDate>Sun, 05 Feb 2023 15:22:58 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_697/</guid>
      <description>LeetCode(697) - Degree of an Array 문제 정수 배열 nums가 주어진다. nums에서 가장 많이 등장하는 정수를 찾고, nums에서 가장 많이 등장하는 정수를 포함하는 sub array를 만들 때, 배열의 길이를 구하라.
입력 Input: nums = [1,2,2,3,1] 출력 Output: 2 설명 가장 많이 등장하는 정수는 1과 2다. 1 혹은 2가 모두 포함되는 배열의 sub array를 만들 면 다음과 같다.  [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] 이 sub array 중 가장 짧은 배열의 길이를 갖는 배열은 [2, 2] 이며, 길이는 2이므로 2를 반환한다.</description>
    </item>
    
    <item>
      <title>LeetCode - Two Sum IV - Input is a BST</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_653/</link>
      <pubDate>Sun, 05 Feb 2023 15:09:52 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_653/</guid>
      <description>LeetCode(653) - Two Sum IV - Input is a BST 문제 Binary Search Tree의 root node 와 정수 k가 주어진다. BST정수 중 두 정수를 조합하여 k를 만들 수 있다면 true를, 아니라면 false를 반환하라.
  입력 Input: root = [5,3,6,2,4,null,7], k = 9 출력 Output: true 풀이 set은 key의 유일성을 보장하며, 고유한 key 검색 시 O(1)의 시간복잡도를 가진다. k - 특정 노드 값이면, 나머지 값에 대해 검색연산을 수행하여 값을 찾을 수 있다.</description>
    </item>
    
    <item>
      <title>[Kubernetes Study] k8s objects - Pod</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-8-pod/</link>
      <pubDate>Sun, 29 Jan 2023 17:00:14 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-8-pod/</guid>
      <description>Pod? 앞선 Study에서 언급된 바와 같이 Kubernetes가 처리하는 가장 작은 단위는 Pod입니다. 이 Pod는 Containerized 애플리케이션을 encapsulation한 단위입니다.
가장 작은 단위의 Kubernetes의 환경을 구성해보겠습니다.
 A Single cluster A Single node A single Pod A single instance in a Pod    사용자가 늘어나 애플리케이션의 처리부하를 줄이기 위해서는 애플리케이션의 instance를 증설해야합니다.
그렇다면 증설은 어떻게 할까요? Containerized 애플리케이션 instance를 Pod에 추가할까요? 앞서 설명했듯이 Kubernetes의 가장 작은 object 단위는 Pod이므로, Pod가 추가로 증설하여 추가되는 부하용량을 처리해야합니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes Study] k8s objects - Recap</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-9-recap/</link>
      <pubDate>Sun, 29 Jan 2023 17:00:14 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-9-recap/</guid>
      <description>Pod? 앞선 Study에서 언급된 바와 같이 Kubernetes가 처리하는 가장 작은 단위는 Pod입니다. 이 Pod는 Containerized 애플리케이션을 encapsulation한 단위입니다.
가장 작은 단위의 Kubernetes의 환경을 구성해보겠습니다.
 A Single cluster A Single node A single Pod A single instance in a Pod    사용자가 늘어나 애플리케이션의 처리부하를 줄이기 위해서는 애플리케이션의 instance를 증설해야합니다.
그렇다면 증설은 어떻게 할까요? Containerized 애플리케이션 instance를 Pod에 추가할까요? 앞서 설명했듯이 Kubernetes의 가장 작은 object 단위는 Pod이므로, Pod가 추가로 증설하여 추가되는 부하용량을 처리해야합니다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Distribute Candies</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_645/</link>
      <pubDate>Sun, 29 Jan 2023 16:05:59 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_645/</guid>
      <description>LeetCode(645) - Set Mismatch 문제 정수형 set이 배열형태로 주어진다. set은 1부터 set의 크기인 n까지 중복되지 않은 값으로 채워져 있어야 한다. nums에 하나의 정수가 다른 정수(1 &amp;lt;= 다른정수&amp;gt; &amp;lt;= n)로 바뀌었다. 이 중복된 수와 원래 있어야 할 수를 찾아 배열 형태로 반환하라.
입력 Input: nums = [1,2,2,4] 출력 Output: [2,3] 풀이 주어진 배열에 대해 중복을 찾아야 하고, 빠진 값 또한 찾아야 한다. 중복된 배열은 map으로 고유성을 찾고, 누락 된 값은 정렬 후 index와 값을 비교하여 다르다면 누락된 값으로 간주한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Distribute Candies</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_599/</link>
      <pubDate>Sun, 29 Jan 2023 15:28:59 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_599/</guid>
      <description>LeetCode(599) - Minimum Index Sum of Two Lists 문제 문자열 배열 list1과 list2가 주어진다. 다음과 같은 조건을 갖는 문자열들을 반환하라.
 list1, list2모두에 존재하는 문자열 문자열 중, 가장 낮은 인덱스를 갖는 문자열 가장 낮은 index가 양쪽 배열 모두 동일하다면 두 문자열을 배열 형태로 반환.  입력 list1 = [&amp;quot;Shogun&amp;quot;,&amp;quot;Tapioca Express&amp;quot;,&amp;quot;Burger King&amp;quot;,&amp;quot;KFC&amp;quot;], list2 = [&amp;quot;Piatti&amp;quot;,&amp;quot;The Grill at Torrey Pines&amp;quot;,&amp;quot;Hungry Hunter Steakhouse&amp;quot;,&amp;quot;Shogun&amp;quot; 출력 Output: [&amp;quot;Shogun&amp;quot;] 풀이 문자열을 key로, index를 value로 하는 map에 list1의 문자열들을 삽입한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Longest Harmonious Subsequence</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_594/</link>
      <pubDate>Fri, 27 Jan 2023 23:37:58 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_594/</guid>
      <description>LeetCode(594) - Longest Harmonious Subsequence 문제 임의의 harmonious array를 정의한다.  harmonious array는 배열의 양 끝단의 수가 그 사이의 수보다 1이 더 큰 배열을 말한다. 배열 nums가 주어질 때, 해당 배열을가지고 가장 긴 harmonious array를 만들었을 때 자리수를 반환하라.
입력 Input: nums = [1,3,2,2,5,2,3,7] 출력 Output: 5  배열 1,3,2,2,5,2,3,7를 이용하여 harmonious array 3,2,2,2,3을 만들 수 있으므로 5를 반환한다.  풀이 map을 이용하여 각 숫자의 출현 횟수를 카운트 한다. map의 첫 번째 pair를 가르키는 prev변수를 생성하고 map을 순회한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Distribute Candies</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_575_distribute_candy/</link>
      <pubDate>Wed, 25 Jan 2023 00:29:52 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_575_distribute_candy/</guid>
      <description>LeetCode(575) - Distribute Candy 문제 Alice는 n개의 캔디를 가지고 있다. i 캔디는 candyTpye[i]의 타입이다. Alice는 살이쪄서 캔디를 줄여야한다..! 주치의는 Alice가 가지고 있는 캔디의 n/2만큼만 먹으라고 한다.
Alice는 최선의 선택을 하고싶다. n/2만큼을 먹어야한다면, 가능한한 많은 종류의 캔디를 먹고싶다. 만약 6종류의 캔디가 있다면, 3종류의 캔디를 먹고, 3종류의 캔디 총 6개가 있다면 있다면 n/2를 한 만큼인 3개만을 먹되, 3종류의 캔디를 먹고싶다. 캔디의 종류를 나타내는 candyType이 주어질 때, Alice가 먹을 수 있는 캔디의 최대 개수를 반환하라.</description>
    </item>
    
    <item>
      <title>[Kubernetes Study] k8s components - kube-proxy</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-7/</link>
      <pubDate>Tue, 24 Jan 2023 22:39:01 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-7/</guid>
      <description>kube-proxy? Kubernetes cluster내에서는 같은 네임스페이스에 있는 각 Pod들은 다른 Pod들과 통신이 가능합니다. 설령 다른 워커노드에 설치된 Pod들도 마찬가지로 통신이 가능합니다. 이러한 통신을 위해서 내부 가상 네트워크인 Pod 네트워크가 필요합니다.
  저는 웹서비스 하나를 운용하고 있으며, 이를 Kubernetes를 통해 운용하고 있다고 가정하겠습니다. 저의 Backend 서버는 Node1에 배치되어 있고, 서비스의 정보를 영구적으로 저장하기 위해 데이터베이스를 사용하며, 데이터베이스는 Node2에 배치되어있습니다.
  Backend 서버는 IP(10.32.0.35)를 통해 데이터베이스에 접근할 수 있습니다. 하지만 데이터베이스가의 IP가 항상 해당 IP를 갖는다는 보장이 없습니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes Study] k8s components - kubelet</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-6/</link>
      <pubDate>Tue, 24 Jan 2023 22:22:42 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-6/</guid>
      <description>kubelet? 앞선 포스팅에서 언급된것 처럼 kubelet은 Cluster를 구성하는 모든 워커노드에 설치됩니다. 이후 Pod배치, Pod상태 조회 요청 등 kube-apiserver의 요구를 받아 Pod의 설치, 삭제, 조회 등 실제적인 작업을 워커노드에서 수행합니다.
Pod의 설치가 요청되면
 kube-scheudler Pod가 설치될 노드들을 파악 후, Node1에 Pod생성을 요청합니다. kube-scheduler의 요청을 받은 kube-apiserver해당 Pod설치 정보를 Node1의 kubelet에 요청합니다. kubelet은 해당 워커노드의 runtime-engine을 통해 Pod를 생성합니다. 작업완료 후 kubelet은 작업완료 내용을 kube-apiserver에 알립니다.    kubelet은 kube-apiserver, kube-scheduler와 달리 Vanilla kubernetes에 포함되어 있지 않습니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes Study] k8s components - kube-scheduler</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-5/</link>
      <pubDate>Tue, 24 Jan 2023 21:56:21 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-5/</guid>
      <description>kube-scheduler? 앞선 포스팅에서 언급된것 처럼 kube-shceduler는 Pod를 배치할 때 어느 노드에 배치될지 결정합니다. kube-scheduler는 Pod의 배치만 결정할 뿐 실제 Pod를 Node에 배치하는 것은 각 노드에 설치된 kubelet이 관장합니다.
kube-scheduler의 역할은 언뜻 보기에는 간단해보입니다. 하지만 실제로는 간단한 작업만을 담당하지 않습니다..!
Cluster에는 수 각 Node에 배치될 수 많은 Pod가 있고, Worker node로 동작하는 Node들이 있을 수 있습니다. Pod가 요구하는 리소스, tolerations, nodeAffinity 등 예외조건들이 있을 수 있으며 현재 노드의 유휴 리소스에 따라 배치 가능한 Pod가 있을 수도, 없을수도 있습니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes Study] k8s components - kube-controller-manager</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-4/</link>
      <pubDate>Tue, 24 Jan 2023 17:16:42 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-4/</guid>
      <description>kube-controller-manager? kube-controller-manager의 역할은 Kubernetes를 구성하하는 다양한 컨트롤러들을 관리하는 것입니다. 컨트롤러들은 운용자로부터 주어진 상태(desired state)를 만족시키기 위해 다음과 같은 역할을 합니다.
 상태 모니터링 상태에 따른 상태 해결(교정)  node-controller는 Cluster를 구성하는 노드들의 상태를 모니터링 합니다. 모니터링은 kube-apiserver를 통해 수행하며 매 5초 마다 상태관리를 수행합니다. 또한 노드의 이상이 감지될 시 40초간의 Grace period를 두어, 40초 이후에도 health check이 실패할 경우 NotReady Status를 만들어 해당 노드로 스케쥴링이 되지 않도록 합니다.
  repliaction-controller는 ReplicaSet관리와 desinered Pod 수를 모니터링하고 관리합니다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Keyboard Row</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_500_keyboard_row/</link>
      <pubDate>Mon, 23 Jan 2023 00:27:27 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_500_keyboard_row/</guid>
      <description>LeetCode(500) - Keyboard Row 문제 string 문자열들의 배열인 words가 주어진다. 일반적인 키보드 배열은 알파벳을 세 줄로 나눌 수 있다. qqwertyuiop가 가장 첫 번째 줄, asdfghjkl가 두 번째 줄 마지막으로 zxcvbnm가 세 번재 줄이다. words를 구성하는 word가, 키보드를 구성하는 세 줄 중 하나의 라인에서 다 완성이 된다면 배열에 삽입하여 해당 배열을 반환하라.
  입력 Input: words = [&amp;quot;Hello&amp;quot;,&amp;quot;Alaska&amp;quot;,&amp;quot;Dad&amp;quot;,&amp;quot;Peace&amp;quot;] 출력 Output: [&amp;quot;Alaska&amp;quot;,&amp;quot;Dad&amp;quot;] 풀이 키보드 배치를 세군데로 나누고, 세 개의 unordered_set을 만들어서 미리 저장한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Longest Palindrome</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_409_longest_palindrome/</link>
      <pubDate>Mon, 16 Jan 2023 23:54:27 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_409_longest_palindrome/</guid>
      <description>LeetCode(409) - Longest Palindrome 문제 문자열 s가 주어진다. 문자열 s의 문자들을 재조합하여 Palidrome을 만들 때 가장 긴 Palidrome의 길이를 반환하라.
입력 Input: s = &amp;quot;abccccdd&amp;quot; 출력 Output: 7 문자열 abccccdd를 재조합해서 가장 큰 길이의 Palidrome을 만들면 dccaccd이므로, 해당 길이인 7을 반환한다.
풀이 unordered_map으로 각 문자들의 출현빈도를 카운팅하고, 짝수 수를 구해 Palidrome을 계산한다. 라고 0. 처럼 생각했는데 짝수를 카운팅 후 Palidrome의 길이를 계산하는 방법을 몰라서 Solution을 보고 같이 map을 써서 본 풀이를 적는다(even이면 전체사이즈를, odd가 1 초과일때 +1 해주면 되는거였다).</description>
    </item>
    
    <item>
      <title>[Kubernetes Study] k8s components - kube-apiserver</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-3/</link>
      <pubDate>Mon, 16 Jan 2023 22:50:26 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-3/</guid>
      <description>kube-apiserver? kube-apiserver는 Kubernetes Cluster를 구성하데 필수적인 컴포넌트로, Cluster를 구성하는 컴포넌트들과 통신을 통해 최신의 상태를 유지할 수 있도록 합니다.
운용자가 kubectl을 통해 CLI 명령을 한다면, kubectl은 사용자의 인증을 진행한 후 변수에 설정된 kube-apiserver주소로 REST Query를 수행합니다. 운용자가 kubectl get node명령어를 통해 현재 cluster에 join 한 노드들의 정보를보려고 한다고 가정하겠습니다. kubectl은 가장 먼저 kube-apiserver는 요청의 정당성을 확인 한 후, kubectl을 통해 요청한 정보 처리를 위해 관련된 정보를 etcd에 쿼리하여 정보를 받아서 운용자에게 응답합니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes Study] k8s components - ETCD</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-2/</link>
      <pubDate>Sun, 15 Jan 2023 23:03:34 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-2/</guid>
      <description>etcd? etcd는 key-value 분산 저장소입니다. 오픈소스이며, Kubernetes에서 사용되어 유명해진 데이터베이스입니다. 분산 저장소라는 말에서 알 수 있듯이 ETCD는 Replication State Machine이며, 분산 컴퓨팅 환경에서 High Availability를 제공하고 높은 신뢰성을 제공합니다. Kubernetes의 다양한 정보들이 ETCD를 통해 저장되므로 고가용성이 중요합니다.
Key-value store? 전통적으로 데이터베이스는 행과 열로 이루어진 Tabular Format 구성됩니다. 관계형 데이터베이스 SQL이 대표적입니다. key-value store는 NoSQL 데이터베이스의 한 종류이며,
Key-value store 구조   위의 테이블은 Tabular Format의 예입니다. 행(Row)는 각 사람들의 정보를 나타내고 열(Column)은 각 타입의 값을 나타냅니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes Study] Cluster Architecture</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-1/</link>
      <pubDate>Sun, 15 Jan 2023 20:26:32 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes-study-1/</guid>
      <description>Kubernetes Study posts들은 Udemy의 Kubernetes 스테디셀러인 Mumshad의 Certified Kubernetes Administrator (CKA) with Practice Tests 강의를 스터디하며 강의 내용을 체득하기 위해 간략하게 정리하는 포스트입니다. 따라서 관련 내용들은 Udemy 강의 내용이며, 아직 다 학습하지는 못했지만.. 강의 내용이 아주 이해하기 쉽게 잘 설명된것 같으니 할인할 때 구매하시면 좋을것 같습니다. 저는 약 19,000에 구매했던것 같습니다.
Kubernetes 구성요소들 Kubernetes는 contaierized 된 application들의 실행, 관리하는 플랫폼입니다. Google에서 처음 개발되었으며 오픈소스 기반으로 현재는 Linux foundation 재단에서 관리합니다. AWS, Azure, GCP 등 Public Cloud 업체들은 Kubernetes 환경을 제공하고 있고 규모가 있는 업체들의 경우 On-premise로 Kubernetes를 구축하여 Service를 제공하고 있습니다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Find the Difference</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_389_find_the_difference/</link>
      <pubDate>Sun, 15 Jan 2023 18:25:02 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_389_find_the_difference/</guid>
      <description>LeetCode(387) - Find the Difference 문제 문자열 s와 t가 주어진다. 문자열 t는 문자열 s를 셔플링하고, 여기에 문자 하나를 추가한 문자열이다. 주어진 문자열 t에서 추가된 문자를 찾아 반환하라.
입력 Input: s = &amp;quot;abcd&amp;quot;, t = &amp;quot;abcde&amp;quot; 출력 Output: &amp;quot;e&amp;quot; 풀이 소문자 알파벳만으로 구성된 문자열이므로, 모든 문자의 출현 빈도를 int[26]으로 해결할 수 있다. int[26] 배열을 s, t용으로 각자 하나씩 만들고, 두 배열을 순회하면서 출현 빈도가 다른 하나의 문자를 반환한다. 문자 계산은 삽입 시 c - &#39;a&#39;로 하여 a는 0 번째 index에 추가되도록 하고, 반환할 때는 index + &#39;a&#39;로 계산하여 index를 알파벳으로 변환한 후 반환한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - First Unique Character in a String</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_387_first_unique_character_in_a_string/</link>
      <pubDate>Sun, 15 Jan 2023 18:01:29 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_387_first_unique_character_in_a_string/</guid>
      <description>LeetCode(387) - First Unique Character in a String 문제 문자열 s가 주어진다. 문자열s를 구성하는 문자 중, 한번만 등장하는 문자를 찾고, 그 중 가장 낮은 index를 가진 문자의 index를 반환하라.
입력 Input: s = &amp;quot;loveleetcode&amp;quot; 출력 Output: 2  문자열 loveleetcode 중 중복되지 않은 문자는 v,t,c,o, 그리고 d 이다. 이 중 가장 낮은 index를 갖는 문자는 v이며, index는 2 이므로, 2를 반환한다.  풀이 문자를 key로 갖고, &amp;lt;int,int&amp;gt; 타입의 pair를 value로 갖는 map을 이용한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Ransom Note</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_383_ransom_note/</link>
      <pubDate>Sat, 14 Jan 2023 20:22:37 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_383_ransom_note/</guid>
      <description>LeetCode(383) - Ransom Note 문제 문자열 ransomNote와 magazine 이 주어진다. ransomNote를 이용해 magazine의 일부를 구성할 수 있다면 true를, 아니라면 false를 반환하라.
 구성에 있어서 순서는 상관이 없다. ransomNote가 aab 이고, magazine이 baa라면, ransomNote의 재배열이 magazine의 일부이므로 true이다.  입력 Input: ransomNote = &amp;quot;aa&amp;quot;, magazine = &amp;quot;aab&amp;quot; 출력 Output: true 풀이 ransomNote를 모두 소비했을 때 magazine의 일부일 경우 true를 반환한다. ransomNote에 있는 문자가 magazine에 없다면 false이다. ransomNote의 문자열을 순회하며 각 문자들을 map에 key로 하고 value는 등장 횟수마다 +1 한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Intersection of Two Arrays II</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_350_intersection_of_two_arrays2/</link>
      <pubDate>Sat, 14 Jan 2023 18:48:45 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_350_intersection_of_two_arrays2/</guid>
      <description>LeetCode(349) - Intersection of Two Arrays II 문제 두 정수 배열 nums1과 nums2가 주어진다. 두 배열에서 공통된 값을 가지는 수의 배열을 반환하라.
 반환되는 배열의 순서는 상관이 없다. 겹치는 값이 여러번이라면, 겹치는 횟수만큼 반환한다.  입력 Input: nums1 = [1,2,2,1], nums2 = [2,2] 출력 Output: [2,2]  nums1에 2 가 두번 존재하고, nums2에도 2가 두 번존재하므로, [2,2]로 반환한다. 만약 nums1에 2가 한 번 등장한다면, 반환은 [2] 이다.  풀이 nums1를 순회하면서 map에 삽입한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Intersection of Two Arrays</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_349_intersection_of_two_arrays/</link>
      <pubDate>Sat, 14 Jan 2023 18:01:03 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_349_intersection_of_two_arrays/</guid>
      <description>LeetCode(349) - Intersection of Two Arrays 문제 두 정수 배열 nums1과 nums2가 주어진다. 두 배열에서 공통된 값을 가지는 수의 배열을 반환하라.
 반환되는 배열의 순서는 상관이 없다. 공통된 값은 중복으로 반환하면 안된다.  입력 Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 출력 Output: [9,4] 풀이 nums1를 순회하면서 map에 삽입한다. nums2를 순회하면서 map에 이미 값이 있는지 확인한다. 값이 있다면 중복된 값이므로 반환될 배열에 삽입한다. 배열은 중복으로 삽입하면 안되므로 이미 값이 존재한다면 무시한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Missing Nuimber</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_268_missing_number/</link>
      <pubDate>Sat, 14 Jan 2023 17:24:09 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_268_missing_number/</guid>
      <description>LeetCode(268) - Missing Number 문제 0 ~ n까지의 수를 가진 배열 nums가 주어진다. nums는 n개의 고유한 수를 가진다. nums에서 누락된 유일한 수 를 반환하라.
입력 Input: nums = [9,6,4,2,3,5,7,0,1] 출력 Output: 8 설명: nums의 크기는 9이며, 이는 9개의 고유한 수를 가진다. 고유한 수는 [0,9] 사이의 값을 가질 수 있다. 8은 이 배열에서 빠져있는 고유한 수이다.
Constraints: n == nums.length 1 &amp;lt;= n &amp;lt;= 104 0 &amp;lt;= nums[i] &amp;lt;= n All the numbers of nums are unique.</description>
    </item>
    
    <item>
      <title>Leetcode 공부 - Valid Anagram</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_242_valid_anagram/</link>
      <pubDate>Sat, 14 Jan 2023 00:06:19 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_242_valid_anagram/</guid>
      <description>LeetCode(242) - Valid Anagram 문제 문자열 s와 t가 주어진다. 두 문자열이 Anagram인지 판단하여 Anagram이면 true를, 아니라면 false를 반환하라.
입력 Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; 출력 Output: true 풀이 s와 t를 정렬하고, 문자열만큼의 길이를 순회하면서 해당 index에 s와 t가 다르다면 false를 반환한다. 문자열 순회가 끝나면 true를 반환한다.  코드 #include&amp;lt;iostream&amp;gt; #include&amp;lt;algorithm&amp;gt; using namespace std; bool isAnagram(string s, string t) { if (s.size() == 0 || t.size() == 0) return false; if (s.</description>
    </item>
    
    <item>
      <title>Leetcode 공부 - Container Duplicate</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_217_contains_duplicate/</link>
      <pubDate>Fri, 13 Jan 2023 23:13:43 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_217_contains_duplicate/</guid>
      <description>LeetCode(217) - Contains Duplicate 문제 정수 배열 nums가 주어진다. 중복된 정수가 배열에 있다면 true를 반환하고 중복이 없다면 false를 반환하라
입력 Input: nums = [1,1,1,3,3,4,3,2,4,2] 출력 Output: true 풀이 배열을 순회하면서 각 값들을 set에 넣는다. set에 현재 배열의 값과 동일한 값이 있다면 중복이므로 true를 반환한다. 배열을 모두 순회했다면 중복이 없으므로 false를 반환한다.  코드 bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_set&amp;lt;int&amp;gt; uset; for(int num : nums) { if(uset.count(num) &amp;gt; 0) { return true; } uset.</description>
    </item>
    
    <item>
      <title>Leetcode 공부 - Majority Element</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_169_majority_element/</link>
      <pubDate>Tue, 10 Jan 2023 23:47:16 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_169_majority_element/</guid>
      <description>LeetCode(169) - Majority Element 문제 n의 길이를 가지는 정수형 배열 nums가 주어진다. nums에 저장된 정수 중 가장 많은 빈도의 정수를 반환하라. 가장 많은 빈도를 갖는 정수는 2/n개 이상이다.
입력 nums = [2,2,1,1,1,2,2] 출력 Output: 2 풀이 key는 정수 값을, value는 정수의 빈도를 나타내는 unordered_map을 사용한다. nums를 순회하면서, 해당 정수의 key를 조회, value의 값을 +1 하여 빈도를 나타낸다. 빈도가 2/n이상이라면 해당 정수가 가장 많은 빈도의 정수이므로, 해당 정수를 반환한다.  코드 class Solution { public: int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_map&amp;lt;int, int&amp;gt; umap; int maxSize = nums.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Intersection of Two Linked Lists</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_160_intersection_of_two_linked_lists/</link>
      <pubDate>Tue, 10 Jan 2023 22:31:16 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_160_intersection_of_two_linked_lists/</guid>
      <description>LeetCode(160) - Intersection of Two Linked Lists 문제 두 Linked List의 headA, headB가 주어진다. 두 List 가 만나는 교차점이 있다면 해당 노드를 반환하고, 두 리스트가 교차하지 않고 평행하다면 null을 반환하라.
입력 Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 skipA, skipB는 주어지는 값이 아닌 설명을 위한 예시이다.
출력 Output: Intersected at &#39;8&#39; 풀이 문제 - Linked List Cycle 와 매우 유사하다. unordered_set을 이용해 ListNode의 고유성을 기준으로 교차점이 있는지 판단한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Linked List Cycle</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_141_linked_list_cycle/</link>
      <pubDate>Tue, 10 Jan 2023 14:50:12 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_141_linked_list_cycle/</guid>
      <description>LeetCode(141) - Linked List Cycle 문제 Linked List의 head가 주어진다. 주어진 Linked List가 cycle을 갖는지 판단하라.
입력 head = [3,2,0,-4], pos = 1 pos는 주어지는 값이 아니고 설명을 돕기위한 예시입니다..
출력 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed). 풀이 ListNode의 포인터는 유니크하므로, 해당 포인터를 set으로 관리하여 중복을 확인한다. ListNode 타입의 unordered_set을 만든다. unordered_set에 현재 ListNode의 포인터가 없다면 현재 노드를 set에 삽입한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Same Tree</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_100_same_tree/</link>
      <pubDate>Mon, 09 Jan 2023 22:30:45 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_100_same_tree/</guid>
      <description>LeetCode(100) - Same Tree 문제 Binary Tree 두 개가 주어진다. 두 Binary Tree가 같은지 비교하여 같다면 True를, 다르다면 False를 반환한다.
입력 root = [1,null,2,3]   출력 [1,3,2] 풀이  주어진 Binary Tree의 root에서 중위순회한다. Inorder traversal은 Bianry Tree에서 좌측 노드를 먼저 순회 후, 자기 자신, 그리고 우측 노드를 탐색하는 방법이다. 주어진 입력에서 root노드는 1, 좌측 노드는 없으므로 자기 자신 1이 먼저 출력되고, 우측 노드로 이동 한다. 우측노드에서는 좌측노드로 이동, 마찬가지고 좌/우 노드가 없으므로 자기 자신이 출력된다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Binary Tree Inorder Traversal</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_94_binary_tree_inorder_traversal/</link>
      <pubDate>Mon, 09 Jan 2023 22:20:19 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_94_binary_tree_inorder_traversal/</guid>
      <description>LeetCode(94) - Binary Tree Inorder Traversal 문제 Binary Tree의 root가 주어진다. Inorder Traversal(중위순회)를 한 결과를 반환하라.
입력 root = [1,null,2,3]   출력 [1,3,2] 풀이  주어진 Binary Tree의 root에서 중위순회한다. Inorder traversal은 Bianry Tree에서 좌측 노드를 먼저 순회 후, 자기 자신, 그리고 우측 노드를 탐색하는 방법이다. 주어진 입력에서 root노드는 1, 좌측 노드는 없으므로 자기 자신 1이 먼저 출력되고, 우측 노드로 이동 한다. 우측노드에서는 좌측노드로 이동, 마찬가지고 좌/우 노드가 없으므로 자기 자신이 출력된다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Merge Sorted Array</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_88_merge_sorted_array/</link>
      <pubDate>Sat, 07 Jan 2023 00:20:44 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_88_merge_sorted_array/</guid>
      <description>LeetCode(88) - Merge Sorted Array 문제 두 개의 오름차순으로 정렬된 정수형 배열 nums1과 nums2가 주어진다. 또한 nums1의 element의 수를 나타내는 m과 nums2의 수를 나타내는 n이 주어진다.
두 배열을 병합하여 오른차순으로 정렬된 배열을 반환하라.
추가적인 배열을 선언하지 않고 nums1에 정렬된 배열을 반환하라.
입력 Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 출력 Output: [1,2,2,3,5,6] 풀이  하나의 배열을 내부적으로 선언하고, 두 배열의 index들을 하나씩 증가하며 새로 선언한 배열 index에 할당한 다음, 입력받은 두 배열을 모두 순회하면 선언한 배열을 nums1이 복사하여 풀 수 있다.</description>
    </item>
    
    <item>
      <title>[Dev/Infra] XXX is not in the sudoers file.  This incident will be reported.</title>
      <link>https://moo-woong.github.io/posts/dev_env/sudoers_permission/</link>
      <pubDate>Tue, 03 Jan 2023 21:25:33 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/dev_env/sudoers_permission/</guid>
      <description>XXX is not in the sudoers file. This incident will be reported. Ubuntu, CentOS 등 리눅스 환경을 새로 설치하면 만나는 오류. 개발 툴을 설정하기 위해 유틸들을 설치할때 sudo를 사용하다 마주하게 된다.
XXX is not in the sudoers file. This incident will be reported. 원인 현재 접속중인 계정이 sudoers에 등록되지 않아 발생한다. sudoers파일에 현재 계정을 등록하여 sudo권한을 주자.
 sudo의 뜻은? &amp;ldquo;super user do&amp;rdquo;.
  su 뜻은? &amp;ldquo;super user&amp;rdquo;
 해결법  su 명령어로 root계정으로 전환  [hugh@localhost ~]$ su Password: #비밀번호 입력 [root@localhost hugh]# [root@localhost hugh]# /etc/sudoers 파일에서 현재 계정을 추가   99 ## Allow root to run any commands anywhere 100 root ALL=(ALL) ALL 101 hugh ALL=(ALL) ALL # &amp;lt;-- sudo권한이 필요한 계정 추가 root계정에서 로그아웃하고 추가한 계정에서 sudo권한이 필요한 명령어 수행  [root@localhost hugh]# exit exit [hugh@localhost ~]$ [hugh@localhost ~]$ [hugh@localhost ~]$ sudo yum install -y vim [sudo] password for hugh: Loaded plugins: fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: mirror.</description>
    </item>
    
    <item>
      <title>VMWare로 Kubernetes 설치하기</title>
      <link>https://moo-woong.github.io/posts/kubernetes/kubernetes/</link>
      <pubDate>Tue, 03 Jan 2023 20:46:06 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/kubernetes/</guid>
      <description>VM생성 및 설정 2개 이상의 CPU Core, 2G이상의 메모리를 설정하여 VM을 생성합니다. 저는 용량이 부족해서 Kubernetes의 최소 요구사항인 2CPU, 2GMem으로 진행하였습니다. 앞으로 진행하는 절차들은 모두 모든 노드에 동일하게 진행합니다.
Guest OS에 SSH 설치 $ sudo apt-get install openssh-server Docker 설치 기본적인 설치는 Docker의 Official Installation Guide를 따릅니다.
Docker repository 설정 apt 관련 repository 설정
 $ sudo apt-get update $ sudo apt-get install \ ca-certificates \ curl \ gnupg \ lsb-release Docker의 공식 GPG Key 추가</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Remove Duplicates from Sorted List</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_83_remove_duplicates_from_sorted_list/</link>
      <pubDate>Thu, 08 Dec 2022 23:40:46 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_83_remove_duplicates_from_sorted_list/</guid>
      <description>LeetCode(83) - Remove Duplicates from Sorted List 문제 정수를 포함하는 구조체 리스트가 정렬되어 주어진다. 중복된 노드를 제외한 리스트 head를 반환하라
입력 Input: head = [1,1,2,3,3] 출력 Output: [1,2,3] 풀이  List를 head부터 NULL이 아닐때 까지 순회하면서 현재 노드의 val과 다음 노드의 val이 같다면, cur 노드의 next를 next-&amp;gt;next로 한칸 건너 뛴다. val과 같지 않다면 cur노드는 다음 노드를 가리킨다.  코드 LeetCode에서 바로 실행해서 이번에는 main이 없습니다.
/** * Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>LeetCodee 공부 - Climbing Stairs</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_70_climbing_stairs/</link>
      <pubDate>Thu, 08 Dec 2022 01:41:17 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_70_climbing_stairs/</guid>
      <description>LeetCode(70) - Climbing Stairs 문제 n개의 단이 있는 계단이 있다. 계단을 오르는 방법은 1칸씩 혹은 2칸씩 오르는 방법이 있다. n번째의 계단을 오르는 방법을 몇개나 있는지 반환하라.
입력 Input: n = 3 출력 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step 풀이  풀때마다 항상 어려운 DP(Dynamic Programming)문제다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Sqrt(x)</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_69_sqrt/</link>
      <pubDate>Thu, 08 Dec 2022 01:07:34 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_69_sqrt/</guid>
      <description>LeetCode(69) - Sqrt(x) 문제 양의 정수 x가 주어질 때, x의 제곱근을 반환하라. 반환되는 제곱근은 정수형으로 내림한 값으로 반환하라.
입력 Input: x = 8 출력 Output: 2 풀이  주어진 양의정수에 대해 양의 제곱근을 반환하는 문제다. 정밀하게 구하는 방식은 뉴튼-랩슨법을 써서 많은 연산을 통해 정확도를 높이지만, 문제는 정수를 반환하는 문제다. 주어지는 x가 매우 큰 값일 경우 1씩 더해서 제곱근을 찾기에는 많은 연산을 필요로 한다. 찾는 제곱근은 양의 제곱근이므로, 1부터 시작해서 x까지 연산해야한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Add Binary</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_67_add_binary/</link>
      <pubDate>Thu, 08 Dec 2022 00:25:33 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_67_add_binary/</guid>
      <description>LeetCode(67) - Add Binary 문제 Binary를 나타내는 문자열 s1, s2가 주어질 때 두 Bianry를 합 한 문자열을 반환하라.
입력 Input: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; 출력 Output: &amp;quot;10101&amp;quot; 풀이  두 문자열의 끝에서 부터 0번 째 index 까지 순회한다. 순회하며 각각 i, j위치에 있는 바이너리를 계산한다. i와 j의 값을 carry에 저장하고, carry는 모듈러 연산을 통해 나머지 값을 반환할 string의 첫 번째 위치에 저장한다. carry는 나누기의 몫을 취하고, 해당 값을 유지한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Longest Substring Without Repeating Characters</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_3_longest_substring_without_repeating_characters/</link>
      <pubDate>Mon, 05 Dec 2022 00:01:19 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_3_longest_substring_without_repeating_characters/</guid>
      <description>LeetCode(3) - Longest Substring Without Repeating Characters 문제 문자열 s가 주어질 때, 이 문자열에서 반복되지 않은 문자를 갖는 substring의 길이를 반환하라.
입력 Input: s = &amp;quot;abcabcbb&amp;quot; 출력 Output: 3 풀이  문제 설명은 간단한데 이해가 잘 안된다. 풀어서 써보자면, 문자열 중에서 중복되지 않은 문자들의 최대 길이를 구하는 문제다. 예를들어, 문자열 s = &amp;quot;abcdea&amp;quot;가 있다면, abcde 까지 중복되지 않은 문자열이므로 결과 값은 5 이다. s = &amp;quot;abcdeafg&amp;quot; 라고 하면, 두 번째 index 부터인 &amp;quot;bcdeafg&amp;quot;에는 중복이 없으므로 이 때 반환값은 문자열 길이 7 이다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Add Two Numbers</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_2_add_two_numbers/</link>
      <pubDate>Sun, 04 Dec 2022 22:19:32 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_2_add_two_numbers/</guid>
      <description>LeetCode(67) - Add Two Numbers 문제 Non-empty 정수 Linked list 두 개가 주어진다. 각 list는 정수의 역방향, 즉 가장 낮은 자리수가 첫 번재 위치한다. 각 리스트의 정수를 더 하여 주어진 리스트와 동일하게 가장 낮은 자리 수의 정수가 먼저 오도록 배치된 LinkList를 반환하라.
입력 Input: l1 = [2,4,3], l2 = [5,6,4] 출력 Output: [7,0,8] 풀이  두 리스트를 모두 순회하면서 리스트가 NULL이 아닐 경우, 해당 val값을 sum 변수에 합한다. carry가 발생할 경우를 고려한다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Plus One</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_66_plus_one/</link>
      <pubDate>Sun, 04 Dec 2022 21:02:51 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_66_plus_one/</guid>
      <description>LeetCode(66) - Plus One 문제 정수를 표현하는 vector&amp;lt;int&amp;gt; digits가 주어진다. digits는 배열로 이루어져 있지만, 정수를 표현한다. 예를들어 [3,2,1] 배열인 경우, 정수 321을 나타낸다. 주어진 digits배열에 +1 한 값을 vector&amp;lt;int&amp;gt;형태로 반환하라.
입력 Input: digits = [4,3,2,1] 출력 Output: [4,3,2,2] 풀이  맨 마지막 정수 값에 +1을 할 수 있겠으나&amp;hellip; carry로 인한 자리수가 변경될 수 있고, 이를 위해서 예외처리가 많아질것 같다. 배열을 정수로 변환하고, 정수를 배열로 변환하도록 한다. &amp;hellip;라고 생각했으나, 자리수가 100자리까지 나오는데 100자리수를 정수형으로 저장할 수 없다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Length of Last Word</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_58_length_of_last_word/</link>
      <pubDate>Sun, 04 Dec 2022 20:43:20 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_58_length_of_last_word/</guid>
      <description>LeetCode(59) - Length of Last Word 문제 단어와 공백으로 이루어진 문자열 s가 주어진다. 마지막 단어의 철자 개수를 반환하라.
입력 Input: s = &amp;quot;luffy is still joyboy&amp;quot; 출력 Output: 6 풀이  string s는 문자와 공백만으로 이루어져 있으므로, string의 맨 뒷 부분 부터 검사하여 문자를 카운트 후 문자 수를 반환한다.  코드 Visual studio에서 바로 실행하도록 임의의 main문을 함께 첨부합니다. lengthOfLastWord()만 보시면 됩니다.
#include&amp;lt;iostream&amp;gt; using namespace std; int lengthOfLastWord(string s) { int count = 0; for (int i = s.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Search Insert Position</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_35_search_insert_position/</link>
      <pubDate>Sun, 04 Dec 2022 19:44:43 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_35_search_insert_position/</guid>
      <description>LeetCode(35) - Search Insert Position 문제 중복을 허용하지 않는 정렬된 integer nums와 integer type의 target이 주어진다. nums배열에서 target을 발견한다면 target이 위치한 index를 반환한다. target을 찾지 못하였다면 target이 포함될 index를 반환한다. time complexity는 O(log n)을 만족해야 한다.
입력  Input: nums = [1,3,5,6], target = 7 출력 Output: 4 풀이  O(log n) 의 조건이 없다면, 정렬된 배열이므로 for loop으로 한번 배열을 순회하면 답을 찾을 수 있다. 하지만 이 경우 Time complexity는 O(n) 이므로 사용할 수 없다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Remove Element</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_27_remove_element/</link>
      <pubDate>Sun, 04 Dec 2022 19:26:04 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_27_remove_element/</guid>
      <description>LeetCode(27) - Remove Element 문제 중복이 허용되며, 정렬되지 않은 integer 배열 nums와 val가 주어진다. nums에서 val가 제거된 배열을 반환한다. 추가적인 array 할당은 할 수 없으며, in-place로 수정한다.
입력  nums = [0,1,2,2,3,0,4,2], val = 2 출력 5, nums = [0,1,4,0,3,_,_,_] 풀이  문제 26과 유사한 내용이다. 전체 배열을 순회하면서 val와 다른 값이라면 count index에 현재 값을 저장한다. 정렬되지 않은 값이라고 하더라도, count index로 in-place에 저장된 값들은 이미 val과 비교된 값이므로, 현재 element와 비교만 하면 된다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Remove Duplicates from Sorted Array</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_26_remove_duplicates_from_sorted_array/</link>
      <pubDate>Sun, 04 Dec 2022 19:12:59 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_26_remove_duplicates_from_sorted_array/</guid>
      <description>LeetCode(26) - Remove Duplicates from Sorted Array 문제 중복이 허용된 integer type의 오름처순 배열에서, 중복된 값들을 제거한 sorted array를 만들고, 중복을 제외한 원소의 개수를 반환하라.
입력 nums = [0,0,1,1,1,2,2,3,3,4] 출력 5, nums = [0,1,2,3,4,_,_,_,_,_] 풀이  추가적인 배열을 할당하지 않고, 주어진 vector&amp;lt;int&amp;gt;를 수정할 것. 그리고 반환하는 원소의 개수 이후의 nums index는 don&amp;rsquo;t care 한다. 주어진 배열을 마사지 해서 반환해야 하므로, 배열을 순회하면서 배열의 값을 바꿔야 한다. 처음 접근은 다음과 같이 진행하였다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Merge Two Sorted Lists</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_21_merge_two_sorted_lists/</link>
      <pubDate>Thu, 01 Dec 2022 23:38:10 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_21_merge_two_sorted_lists/</guid>
      <description>LeetCode(21) - Merge Two Sorted Lists 문제 두 Linked List의 header가 주어진다. 두 리스트를 정렬하여 하나의 리스트로 반환하라.
입력 list1 = [1,2,4], list2 = [1,3,4] 출력 [1,1,2,3,4,4] 풀이  두 리스트를 순회하면서 작은값을 취하고, 취한 리스트는 다음 노드로 이동하여 두 리스트가 모두 NULL일 때 까지 순회한다. 두 리스트는 모두 정렬된 상태이므로, 함수 도입부에서 한 리스트가 NULL이라면 다른 리스트를 반환한다. 두 리스트 모두 NULL인 경우가 있어서 헷갈렸는데, list1이 NULL일 경우 NULL인 list2를 리턴해도 무방했다.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Valid Parentheses</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_20_valid_parentheses/</link>
      <pubDate>Thu, 01 Dec 2022 23:05:08 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_20_valid_parentheses/</guid>
      <description>LeetCode(20) - Valid Parentheses 문제 소괄호, 중괄호, 대괄호로 이루어진 문자열이 주어진다. 이 문자열의 괄호들이 알맞은 pair라면 true를, 아니라면 false를 반환한다.
입력  s = &amp;quot;()[]{}&amp;quot; 출력 true 풀이  전형적인 stack문제로, 괄호가 닫힐때 마다 pair를 확인한다. 주어진 문자열의 문자들을 순회하면서 문자가 여는괄호면 stack에 쌓고, 닫는 괄호라면, 현재 stack에서 top()과 pair비교 후 pair라면 pop을, 아니면 false를 리턴한다.  코드 Visual studio에서 바로 실행하도록 임의의 main문을 함께 첨부합니다. isValid()만 보시면 됩니다.
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;stack&amp;gt; using namespace std; bool isValid(string s) { stack&amp;lt;char&amp;gt; st; for (char c : s) { if (c == &#39;(&#39; || c == &#39;{&#39; || c == &#39;[&#39;) { st.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Longest Common Prefix</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_14_longest_common_prefix/</link>
      <pubDate>Thu, 01 Dec 2022 22:37:08 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_14_longest_common_prefix/</guid>
      <description>LeetCode(14) - Longest Common Prefix 문제 문자열 배열이 주어진다. 이 문자열 배열에서 문자가 공통인 부분만큼 문자열로 반환하라.
입력 strs = [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] 출력 &amp;quot;fl&amp;quot; 풀이  문자열들을 사전순으로 정렬하고, 첫 번째 문자열을 기준으로 비교하여 같은 문자라면 index를 순차적으로 증가시킨다. 문자가 같을 때 까지 증가하다가 다른 문자가 나오면 기존까지 저장한 문자열을 반환한다.  코드 string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) { vector&amp;lt;string&amp;gt; s = strs; sort(s.begin(), s.end()); string ret = &amp;quot;&amp;quot;; string pilot = s.at(0); for (int i = 0; i &amp;lt; pilot.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Palindrome Number</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_9_palindrome_number/</link>
      <pubDate>Thu, 01 Dec 2022 00:27:00 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_9_palindrome_number/</guid>
      <description>LeetCode(9) - Palindrome Number 문제 integer x가 주어질 때, x가 Palindrome(회문)을 만족하면 true를 return, 아니라면 false를 리턴
입력 x = 121 출력 true 풀이  입력 x를 string으로 변환 앞부분을 가르키는 index front와 뒷부분을 가르키는 index back을 만들어 앞부분은 증가를, 뒷부분은 감소하며 전체 string 비교 front가 back보다 커질 때 까지 비교하여 front가 back보다 커진다면 회문으로 판단, 순회를 종료하고 true반환. 비교 중 다른 값이 나온다면 곧바로 false반환  코드 class Solution { public: bool isPalindrome(int x) { string s = to_string(x); int front = 0, back = s.</description>
    </item>
    
    <item>
      <title>LeetCode 공부 - Two Sum</title>
      <link>https://moo-woong.github.io/posts/algorithm/algo_1_two_some/</link>
      <pubDate>Wed, 30 Nov 2022 23:23:39 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/algorithm/algo_1_two_some/</guid>
      <description>LeetCode(1) - Two Sum 문제 integer 배열과 target이 주어질 때, 배열에서 두 정수의 합이 target을 만족하는 두 index를 반환
입력 nums = [2,7,11,15], target = 9 출력 [0,1] 풀이  배열 순회 중 현재 배열의 값과 target과의 diff 값이 hash table에 있으면, diff key의 value와 현재 배열 index를 리턴. hash table에 diff값이 없으면, 현재 배열 index의 value를 key로, index를 value로 table에 저장. 배열 순회.  코드 class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { unordered_map&amp;lt;int, int&amp;gt; umap; vector&amp;lt;int&amp;gt; ret; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>Ubuntu에 Minikube 설치하기</title>
      <link>https://moo-woong.github.io/posts/kubernetes/minikube/</link>
      <pubDate>Tue, 01 Nov 2022 22:54:51 +0900</pubDate>
      
      <guid>https://moo-woong.github.io/posts/kubernetes/minikube/</guid>
      <description>Minikube 설치 Kubernetes 학습을 위해서 환경이 필요하게 되었습니다. 개인 학습을 위해서는 Vanilla k8s, Amazon EKS, 그리고 Minikube 등 다양한 학습환경이 있습니다. 저는 Minikube로 선택했습니다. 이유는 다음과 같습니다.
 Vanilla k8s는 환경설정에 많은 리소스도 필요하고 회사에서 proxy환경에서 설치하는데 애를 많이 먹은 기억이 있어서 환경설정에 많은 시간을 할애하기 싫었습니다. Amazon EKS는 간단하게 구축이 가능하지만 약간의 비용이 발생할 수 있다는 점, 그리고 지지고 볶고 뜯고 맛보고 즐겨야하는데 EKS에서는 잘 할 수 있을까?에 대한 의구심이 있어 Amazon EKS 사용은 나중으로 미뤘습니다.</description>
    </item>
    
    <item>
      <title>Github Blog와 Hugo로 블로그 개설하기</title>
      <link>https://moo-woong.github.io/posts/2022-10-17-github-hugo/</link>
      <pubDate>Sun, 16 Oct 2022 08:15:52 -0700</pubDate>
      
      <guid>https://moo-woong.github.io/posts/2022-10-17-github-hugo/</guid>
      <description>GitHub Blog와 Hugo로 블로그 만들기 개요 회사만 다니다보니 이 핑계, 저 핑계를 대며 개인업무 역량관리에 소홀한게 느껴졌습니다. 과거에도 공부할 때 하나하나 PPT자료를 만들며 체득했던 전공 공부, 정보들은 저한테는 좋은 경험이었습니다. 이에 대한 경험으로 블로그를 만들어 공부도 하고, 정리한 정보들을 공유하여 찾아오는 분들에게 득이되도록 하고 싶어 블로그를 만들어보게 되었습니다. 앞으로도 잘 부탁드리며 블로그 구축부터 정리해보겠습니다.
환경  Blog: Github + Hugo Host machine: Ubuntu 20.04 LTS + VMWare workstation 16 Editor: VS Code on Windows  환경 선택에 대해서는 특별한 이유는 없습니다.</description>
    </item>
    
  </channel>
</rss>
